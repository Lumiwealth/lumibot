<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="30" skipped="25" tests="1021" time="2037.390" timestamp="2025-10-05T16:26:24.143602-04:00" hostname="Roberts-MacBook-Pro.local"><testcase classname="" name="tests.backtest.test_strategy_executor" time="0.000"><skipped message="collection skipped">('/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/backtest/test_strategy_executor.py', 11, 'Skipped: all tests still WIP')</skipped></testcase><testcase classname="" name="tests.test_projectx_live_flow" time="0.000"><skipped message="collection skipped">('/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_projectx_live_flow.py', 8, 'Skipped: Removed ProjectX live flow test (requires credentials)')</skipped></testcase><testcase classname="" name="tests.test_tradier_data" time="0.000"><skipped message="collection skipped">('/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_tradier_data.py', 22, 'Skipped: These tests require a Tradier API key')</skipped></testcase><testcase classname="tests.backtest.test_accuracy_verification.TestAccuracyVerification" name="test_one_year_amzn_accuracy" time="13.423"><failure message="AssertionError: Portfolio variance 6.7963% exceeds 0.01% threshold&#10;assert 6.796300000000002 &lt; 0.01">self = &lt;tests.backtest.test_accuracy_verification.TestAccuracyVerification object at 0x11be6d5b0&gt;

    def test_one_year_amzn_accuracy(self):
        """
        Test 1: Verify AMZN accuracy over 1 year (2023)
    
        Expected:
        - Portfolio variance &lt; 0.01% ($10 on $100k portfolio)
        - Price differences remain sub-penny
        - No systematic directional bias
        """
        backtesting_start = datetime.datetime(2023, 1, 3)  # First trading day of 2023
        backtesting_end = datetime.datetime(2023, 12, 29)  # Last trading day of 2023
    
        print("\n" + "="*80)
        print("TEST 1: ONE YEAR ACCURACY VERIFICATION - AMZN")
        print("="*80)
        print(f"Period: {backtesting_start.date()} to {backtesting_end.date()}")
        print(f"Symbol: AMZN")
        print(f"Trading days: ~252")
    
        # Run ThetaData backtest
        print("\n[1/2] Running ThetaData backtest...")
        theta_results, theta_strat = AccuracyTestStrategy.run_backtest(
            ThetaDataBacktesting,
            backtesting_start,
            backtesting_end,
            benchmark_asset="SPY",
            show_plot=False,
            show_tearsheet=False,
            save_tearsheet=False,
            parameters={"symbol": "AMZN", "quantity": 100},
            thetadata_username=THETADATA_USERNAME,
            thetadata_password=THETADATA_PASSWORD,
        )
    
        # Run Polygon backtest
        print("\n[2/2] Running Polygon backtest...")
        polygon_results, polygon_strat = AccuracyTestStrategy.run_backtest(
            PolygonDataBacktesting,
            backtesting_start,
            backtesting_end,
            benchmark_asset="SPY",
            show_plot=False,
            show_tearsheet=False,
            save_tearsheet=False,
            parameters={"symbol": "AMZN", "quantity": 100},
            polygon_api_key=POLYGON_API_KEY,
        )
    
        # Compare results - get final portfolio value from strategy
        theta_final = theta_strat.get_portfolio_value()
        polygon_final = polygon_strat.get_portfolio_value()
        difference = abs(theta_final - polygon_final)
        percent_diff = (difference / polygon_final) * 100
    
        print("\n" + "-"*80)
        print("RESULTS:")
        print("-"*80)
        print(f"ThetaData Final Portfolio Value:  ${theta_final:,.2f}")
        print(f"Polygon Final Portfolio Value:    ${polygon_final:,.2f}")
        print(f"Absolute Difference:              ${difference:,.2f}")
        print(f"Percentage Difference:            {percent_diff:.4f}%")
        print(f"Acceptance Threshold:             0.01% (${polygon_final * 0.0001:,.2f})")
    
        # Verify acceptance criteria
&gt;       assert percent_diff &lt; 0.01, f"Portfolio variance {percent_diff:.4f}% exceeds 0.01% threshold"
E       AssertionError: Portfolio variance 6.7963% exceeds 0.01% threshold
E       assert 6.796300000000002 &lt; 0.01

tests/backtest/test_accuracy_verification.py:124: AssertionError</failure></testcase><testcase classname="tests.backtest.test_accuracy_verification.TestAccuracyVerification" name="test_multi_symbol_price_ranges" time="56.740"><failure message="AssertionError: SPY: Variance 0.0135% exceeds 0.01%&#10;assert 0.013531849903992286 &lt; 0.01">self = &lt;tests.backtest.test_accuracy_verification.TestAccuracyVerification object at 0x11c241160&gt;

    def test_multi_symbol_price_ranges(self):
        """
        Test 2: Verify accuracy across different price ranges
    
        Tests 5 symbols with different price points:
        - AMZN: ~$180
        - AAPL: ~$175
        - GOOGL: ~$140
        - SPY: ~$450
        - BRK.B: ~$420
    
        Expected:
        - 0.5¢ variance is consistent percentage across all price ranges
        - Sub-penny differences for all symbols
        """
        backtesting_start = datetime.datetime(2024, 8, 1)
        backtesting_end = datetime.datetime(2024, 8, 5)  # 1 week for speed
    
        symbols = [
            ("AMZN", 10, 180),   # ~$180/share, 10 shares
            ("AAPL", 10, 175),   # ~$175/share, 10 shares
            ("GOOGL", 10, 140),  # ~$140/share, 10 shares
            ("SPY", 10, 450),    # ~$450/share, 10 shares
            ("BRK.B", 5, 420),   # ~$420/share, 5 shares
        ]
    
        print("\n" + "="*80)
        print("TEST 2: MULTI-SYMBOL PRICE RANGE VERIFICATION")
        print("="*80)
        print(f"Period: {backtesting_start.date()} to {backtesting_end.date()}")
        print(f"Symbols: {len(symbols)}")
    
        results_table = []
    
        for symbol, qty, approx_price in symbols:
            print(f"\n--- Testing {symbol} (~${approx_price}/share, {qty} shares) ---")
    
            # Run ThetaData backtest
            theta_results, theta_strat = AccuracyTestStrategy.run_backtest(
                ThetaDataBacktesting,
                backtesting_start,
                backtesting_end,
                benchmark_asset="SPY",
                show_plot=False,
                show_tearsheet=False,
                save_tearsheet=False,
                parameters={"symbol": symbol, "quantity": qty},
                thetadata_username=THETADATA_USERNAME,
                thetadata_password=THETADATA_PASSWORD,
            )
    
            # Run Polygon backtest
            polygon_results, polygon_strat = AccuracyTestStrategy.run_backtest(
                PolygonDataBacktesting,
                backtesting_start,
                backtesting_end,
                benchmark_asset="SPY",
                show_plot=False,
                show_tearsheet=False,
                save_tearsheet=False,
                parameters={"symbol": symbol, "quantity": qty},
                polygon_api_key=POLYGON_API_KEY,
            )
    
            # Compare final portfolio values
            theta_final = theta_strat.get_portfolio_value()
            polygon_final = polygon_strat.get_portfolio_value()
            difference = abs(theta_final - polygon_final)
            percent_diff = (difference / polygon_final) * 100
    
            results_table.append({
                "symbol": symbol,
                "price": approx_price,
                "qty": qty,
                "theta": theta_final,
                "polygon": polygon_final,
                "diff": difference,
                "pct": percent_diff
            })
    
            print(f"  ThetaData:  ${theta_final:,.2f}")
            print(f"  Polygon:    ${polygon_final:,.2f}")
            print(f"  Difference: ${difference:,.2f} ({percent_diff:.4f}%)")
    
            # Verify sub-0.01% variance for each symbol
&gt;           assert percent_diff &lt; 0.01, f"{symbol}: Variance {percent_diff:.4f}% exceeds 0.01%"
E           AssertionError: SPY: Variance 0.0135% exceeds 0.01%
E           assert 0.013531849903992286 &lt; 0.01

tests/backtest/test_accuracy_verification.py:214: AssertionError</failure></testcase><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_process_pending_orders_equity_appies_fee_once" time="0.171" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_process_pending_orders_crypto_keeps_cash_consistent" time="0.170" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_bracket_order_entry_and_exit_cash_consistency" time="0.176" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_buy_orders_fill_at_expected_prices[market_buy]" time="0.173" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_buy_orders_fill_at_expected_prices[limit_between_range]" time="0.172" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_buy_orders_fill_at_expected_prices[limit_gap_down]" time="0.173" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_buy_orders_fill_at_expected_prices[stop_gap_up]" time="0.171" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_buy_orders_fill_at_expected_prices[stop_limit_trigger]" time="0.183" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_buy_orders_fill_at_expected_prices[market_fractional]" time="0.181" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_buy_orders_fill_at_expected_prices[stop_fractional]" time="0.173" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_limit_order_remains_open_when_price_not_reached" time="0.171" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_sell_orders_fill_at_expected_prices[market_sell]" time="0.174" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_sell_orders_fill_at_expected_prices[limit_sell]" time="0.177" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_sell_orders_fill_at_expected_prices[stop_sell]" time="0.177" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_sell_orders_fill_at_expected_prices[stop_limit_sell]" time="0.177" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_sell_orders_fill_at_expected_prices[limit_fractional]" time="0.176" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_sell_orders_fill_at_expected_prices[stop_fractional]" time="0.175" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_trailing_stop_sell_triggers_after_price_drop" time="0.177" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_bracket_order_stop_exit_executes" time="0.171" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_bracket_order_trailing_exit_executes" time="0.175" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_crypto_market_sell_returns_quote_balance" time="0.173" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_crypto_limit_order_not_filled_when_price_not_hit" time="0.171" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_forex_market_buy_updates_positions" time="0.173" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_percent_fee_is_applied_once" time="0.171" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_flat_fee_is_applied_once" time="0.171" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_multiple_orders_in_single_cycle_all_fill" time="0.172" /><testcase classname="tests.backtest.test_backtesting_broker_processing" name="test_missing_bar_falls_back_to_last_available_price" time="0.172" /><testcase classname="tests.backtest.test_crypto_cash_regressions" name="test_crypto_cash_regression_no_fees[price_map0]" time="5.152" /><testcase classname="tests.backtest.test_crypto_cash_regressions" name="test_crypto_cash_regression_no_fees[price_map1]" time="4.636" /><testcase classname="tests.backtest.test_crypto_cash_regressions" name="test_crypto_cash_regression_with_fees" time="6.771" /><testcase classname="tests.backtest.test_daily_data_timestamp_comparison.TestDailyDataTimestampComparison" name="test_daily_data_full_month_pltr" time="4.336"><failure message="Failed: CRITICAL: ThetaData returned NO daily data for PLTR">self = &lt;tests.backtest.test_daily_data_timestamp_comparison.TestDailyDataTimestampComparison object at 0x11c1fbef0&gt;

    def test_daily_data_full_month_pltr(self):
        """Test PLTR daily data for full September 2023 - ZERO tolerance."""
&gt;       self._test_symbol_daily_data(
            symbol="PLTR",
            start_date=datetime.datetime(2023, 9, 1),
            end_date=datetime.datetime(2023, 9, 30),
            min_trading_days=19
        )

tests/backtest/test_daily_data_timestamp_comparison.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tests.backtest.test_daily_data_timestamp_comparison.TestDailyDataTimestampComparison object at 0x11c1fbef0&gt;
symbol = 'PLTR', start_date = datetime.datetime(2023, 9, 1, 0, 0)
end_date = datetime.datetime(2023, 9, 30, 0, 0), min_trading_days = 19

    def _test_symbol_daily_data(self, symbol, start_date, end_date, min_trading_days):
        """
        Core test function that validates daily data for a symbol.
    
        CRITICAL CHECKS:
        1. Both sources return data
        2. Same number of trading days
        3. IDENTICAL timestamps (no shifts)
        4. OHLC within 0.01 (penny) tolerance
        5. Volume reasonable
        6. No duplicate dates
        7. No missing dates (within market calendar)
        """
        username = os.environ.get("THETADATA_USERNAME")
        password = os.environ.get("THETADATA_PASSWORD")
        polygon_api_key = os.environ.get("POLYGON_API_KEY")
    
        asset = Asset(symbol, asset_type="stock")
    
        print(f"\n{'='*80}")
        print(f"TESTING {symbol} DAILY DATA: {start_date.date()} to {end_date.date()}")
        print(f"{'='*80}")
    
        # ==== GET THETADATA DAILY DATA ====
        print(f"\n1. Fetching ThetaData daily data...")
        try:
            theta_df = thetadata_helper.get_price_data(
                username=username,
                password=password,
                asset=asset,
                start=start_date,
                end=end_date,
                timespan="day"
            )
        except Exception as e:
            pytest.fail(f"CRITICAL: ThetaData daily data FAILED for {symbol}: {e}")
    
        if theta_df is None or len(theta_df) == 0:
&gt;           pytest.fail(f"CRITICAL: ThetaData returned NO daily data for {symbol}")
E           Failed: CRITICAL: ThetaData returned NO daily data for PLTR

tests/backtest/test_daily_data_timestamp_comparison.py:114: Failed</failure></testcase><testcase classname="tests.backtest.test_daily_data_timestamp_comparison.TestDailyDataTimestampComparison" name="test_daily_data_full_month_spy" time="1.875"><failure message="Failed: CRITICAL: ThetaData returned NO daily data for SPY">self = &lt;tests.backtest.test_daily_data_timestamp_comparison.TestDailyDataTimestampComparison object at 0x11c1f9820&gt;

    def test_daily_data_full_month_spy(self):
        """Test SPY daily data for full September 2023 - ZERO tolerance."""
&gt;       self._test_symbol_daily_data(
            symbol="SPY",
            start_date=datetime.datetime(2023, 9, 1),
            end_date=datetime.datetime(2023, 9, 30),
            min_trading_days=19
        )

tests/backtest/test_daily_data_timestamp_comparison.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tests.backtest.test_daily_data_timestamp_comparison.TestDailyDataTimestampComparison object at 0x11c1f9820&gt;
symbol = 'SPY', start_date = datetime.datetime(2023, 9, 1, 0, 0)
end_date = datetime.datetime(2023, 9, 30, 0, 0), min_trading_days = 19

    def _test_symbol_daily_data(self, symbol, start_date, end_date, min_trading_days):
        """
        Core test function that validates daily data for a symbol.
    
        CRITICAL CHECKS:
        1. Both sources return data
        2. Same number of trading days
        3. IDENTICAL timestamps (no shifts)
        4. OHLC within 0.01 (penny) tolerance
        5. Volume reasonable
        6. No duplicate dates
        7. No missing dates (within market calendar)
        """
        username = os.environ.get("THETADATA_USERNAME")
        password = os.environ.get("THETADATA_PASSWORD")
        polygon_api_key = os.environ.get("POLYGON_API_KEY")
    
        asset = Asset(symbol, asset_type="stock")
    
        print(f"\n{'='*80}")
        print(f"TESTING {symbol} DAILY DATA: {start_date.date()} to {end_date.date()}")
        print(f"{'='*80}")
    
        # ==== GET THETADATA DAILY DATA ====
        print(f"\n1. Fetching ThetaData daily data...")
        try:
            theta_df = thetadata_helper.get_price_data(
                username=username,
                password=password,
                asset=asset,
                start=start_date,
                end=end_date,
                timespan="day"
            )
        except Exception as e:
            pytest.fail(f"CRITICAL: ThetaData daily data FAILED for {symbol}: {e}")
    
        if theta_df is None or len(theta_df) == 0:
&gt;           pytest.fail(f"CRITICAL: ThetaData returned NO daily data for {symbol}")
E           Failed: CRITICAL: ThetaData returned NO daily data for SPY

tests/backtest/test_daily_data_timestamp_comparison.py:114: Failed</failure></testcase><testcase classname="tests.backtest.test_daily_data_timestamp_comparison.TestDailyDataTimestampComparison" name="test_daily_data_full_month_aapl" time="2.571"><failure message="Failed: CRITICAL: ThetaData returned NO daily data for AAPL">self = &lt;tests.backtest.test_daily_data_timestamp_comparison.TestDailyDataTimestampComparison object at 0x11c1fa4b0&gt;

    def test_daily_data_full_month_aapl(self):
        """Test AAPL daily data for full September 2023 - ZERO tolerance."""
&gt;       self._test_symbol_daily_data(
            symbol="AAPL",
            start_date=datetime.datetime(2023, 9, 1),
            end_date=datetime.datetime(2023, 9, 30),
            min_trading_days=19
        )

tests/backtest/test_daily_data_timestamp_comparison.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tests.backtest.test_daily_data_timestamp_comparison.TestDailyDataTimestampComparison object at 0x11c1fa4b0&gt;
symbol = 'AAPL', start_date = datetime.datetime(2023, 9, 1, 0, 0)
end_date = datetime.datetime(2023, 9, 30, 0, 0), min_trading_days = 19

    def _test_symbol_daily_data(self, symbol, start_date, end_date, min_trading_days):
        """
        Core test function that validates daily data for a symbol.
    
        CRITICAL CHECKS:
        1. Both sources return data
        2. Same number of trading days
        3. IDENTICAL timestamps (no shifts)
        4. OHLC within 0.01 (penny) tolerance
        5. Volume reasonable
        6. No duplicate dates
        7. No missing dates (within market calendar)
        """
        username = os.environ.get("THETADATA_USERNAME")
        password = os.environ.get("THETADATA_PASSWORD")
        polygon_api_key = os.environ.get("POLYGON_API_KEY")
    
        asset = Asset(symbol, asset_type="stock")
    
        print(f"\n{'='*80}")
        print(f"TESTING {symbol} DAILY DATA: {start_date.date()} to {end_date.date()}")
        print(f"{'='*80}")
    
        # ==== GET THETADATA DAILY DATA ====
        print(f"\n1. Fetching ThetaData daily data...")
        try:
            theta_df = thetadata_helper.get_price_data(
                username=username,
                password=password,
                asset=asset,
                start=start_date,
                end=end_date,
                timespan="day"
            )
        except Exception as e:
            pytest.fail(f"CRITICAL: ThetaData daily data FAILED for {symbol}: {e}")
    
        if theta_df is None or len(theta_df) == 0:
&gt;           pytest.fail(f"CRITICAL: ThetaData returned NO daily data for {symbol}")
E           Failed: CRITICAL: ThetaData returned NO daily data for AAPL

tests/backtest/test_daily_data_timestamp_comparison.py:114: Failed</failure></testcase><testcase classname="tests.backtest.test_daily_data_timestamp_comparison.TestDailyDataTimestampComparison" name="test_daily_data_full_month_amzn" time="2.781"><failure message="AssertionError: CRITICAL: ThetaData has only 6 days, expected &gt;=19&#10;assert 6 &gt;= 19&#10; +  where 6 = len(                               open      high       low     close   volume  count\ndatetime                                                                         \n2024-07-26 13:29:00+00:00 180.98000 182.86000 177.42000 180.43500   685645  12112\n2024-07-29 13:29:00+00:00 182.76000 184.30000 179.70000 183.83000   476242   9588\n2024-07-30 13:29:00+00:00 182.88000 184.80000 182.74200 184.72000  2963971   6850\n2024-07-31 13:29:00+00:00 182.10000 186.59500 175.10000 185.05030  1315359  22716\n2024-08-01 13:29:00+00:00 190.84000 191.49000 184.62000 189.29000  1126950  23392\n2024-08-02 13:29:00+00:00 168.55000 189.74500 165.31000 166.79000  4929392  86719)">self = &lt;tests.backtest.test_daily_data_timestamp_comparison.TestDailyDataTimestampComparison object at 0x11c1fb230&gt;

    def test_daily_data_full_month_amzn(self):
        """Test AMZN daily data for full September 2023 - ZERO tolerance."""
&gt;       self._test_symbol_daily_data(
            symbol="AMZN",
            start_date=datetime.datetime(2023, 9, 1),
            end_date=datetime.datetime(2023, 9, 30),
            min_trading_days=19
        )

tests/backtest/test_daily_data_timestamp_comparison.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tests.backtest.test_daily_data_timestamp_comparison.TestDailyDataTimestampComparison object at 0x11c1fb230&gt;
symbol = 'AMZN', start_date = datetime.datetime(2023, 9, 1, 0, 0)
end_date = datetime.datetime(2023, 9, 30, 0, 0), min_trading_days = 19

    def _test_symbol_daily_data(self, symbol, start_date, end_date, min_trading_days):
        """
        Core test function that validates daily data for a symbol.
    
        CRITICAL CHECKS:
        1. Both sources return data
        2. Same number of trading days
        3. IDENTICAL timestamps (no shifts)
        4. OHLC within 0.01 (penny) tolerance
        5. Volume reasonable
        6. No duplicate dates
        7. No missing dates (within market calendar)
        """
        username = os.environ.get("THETADATA_USERNAME")
        password = os.environ.get("THETADATA_PASSWORD")
        polygon_api_key = os.environ.get("POLYGON_API_KEY")
    
        asset = Asset(symbol, asset_type="stock")
    
        print(f"\n{'='*80}")
        print(f"TESTING {symbol} DAILY DATA: {start_date.date()} to {end_date.date()}")
        print(f"{'='*80}")
    
        # ==== GET THETADATA DAILY DATA ====
        print(f"\n1. Fetching ThetaData daily data...")
        try:
            theta_df = thetadata_helper.get_price_data(
                username=username,
                password=password,
                asset=asset,
                start=start_date,
                end=end_date,
                timespan="day"
            )
        except Exception as e:
            pytest.fail(f"CRITICAL: ThetaData daily data FAILED for {symbol}: {e}")
    
        if theta_df is None or len(theta_df) == 0:
            pytest.fail(f"CRITICAL: ThetaData returned NO daily data for {symbol}")
    
        print(f"   ✓ ThetaData: {len(theta_df)} daily bars")
        print(f"   Date range: {theta_df.index[0]} to {theta_df.index[-1]}")
    
        # ==== GET POLYGON DAILY DATA ====
        print(f"\n2. Fetching Polygon daily data...")
        try:
            polygon_df = polygon_get_price_data(
                api_key=polygon_api_key,
                asset=asset,
                start=start_date,
                end=end_date,
                timespan="day",
                quote_asset=Asset("USD", asset_type="forex")
            )
        except Exception as e:
            pytest.fail(f"CRITICAL: Polygon daily data FAILED for {symbol}: {e}")
    
        if polygon_df is None or len(polygon_df) == 0:
            pytest.fail(f"CRITICAL: Polygon returned NO daily data for {symbol}")
    
        print(f"   ✓ Polygon: {len(polygon_df)} daily bars")
        print(f"   Date range: {polygon_df.index[0]} to {polygon_df.index[-1]}")
    
        # ==== CHECK 1: Minimum Trading Days ====
        print(f"\n3. Verifying minimum trading days...")
&gt;       assert len(theta_df) &gt;= min_trading_days, \
            f"CRITICAL: ThetaData has only {len(theta_df)} days, expected &gt;={min_trading_days}"
E       AssertionError: CRITICAL: ThetaData has only 6 days, expected &gt;=19
E       assert 6 &gt;= 19
E        +  where 6 = len(                               open      high       low     close   volume  count\ndatetime                                                                         \n2024-07-26 13:29:00+00:00 180.98000 182.86000 177.42000 180.43500   685645  12112\n2024-07-29 13:29:00+00:00 182.76000 184.30000 179.70000 183.83000   476242   9588\n2024-07-30 13:29:00+00:00 182.88000 184.80000 182.74200 184.72000  2963971   6850\n2024-07-31 13:29:00+00:00 182.10000 186.59500 175.10000 185.05030  1315359  22716\n2024-08-01 13:29:00+00:00 190.84000 191.49000 184.62000 189.29000  1126950  23392\n2024-08-02 13:29:00+00:00 168.55000 189.74500 165.31000 166.79000  4929392  86719)

tests/backtest/test_daily_data_timestamp_comparison.py:141: AssertionError</failure></testcase><testcase classname="tests.backtest.test_databento.TestDatabentoBacktestFull" name="test_databento_continuous_futures_minute_data" time="10.980"><failure message="AssertionError: Expected valid price, got None&#10;assert (None is not None)">self = &lt;tests.backtest.test_databento.TestDatabentoBacktestFull object at 0x11c1bfce0&gt;

    @pytest.mark.apitest
    @pytest.mark.skipif(
        not DATABENTO_API_KEY,
        reason="This test requires a Databento API key"
    )
    @pytest.mark.skipif(
        DATABENTO_API_KEY == '&lt;your key here&gt;',
        reason="This test requires a Databento API key"
    )
    def test_databento_continuous_futures_minute_data(self):
        """
        Test Databento with continuous futures (ES) using minute-level data.
        Tests a 2-day period in 2025 to verify minute-level cadence works correctly.
        """
        # Use timezone-aware datetimes for futures trading
        tzinfo = pytz.timezone("America/New_York")
        backtesting_start = tzinfo.localize(datetime.datetime(2025, 1, 2, 9, 30))
        backtesting_end = tzinfo.localize(datetime.datetime(2025, 1, 3, 16, 0))
    
        data_source = DataBentoDataBacktesting(
            datetime_start=backtesting_start,
            datetime_end=backtesting_end,
            databento_key=DATABENTO_API_KEY,
        )
    
        broker = BacktestingBroker(data_source=data_source)
    
        strat_obj = SimpleContinuousFutures(
            broker=broker,
        )
    
        trader = Trader(logfile="", backtest=True)
        trader.add_strategy(strat_obj)
        results = trader.run_all(
            show_plot=False,
            show_tearsheet=False,
            show_indicators=False,
            save_tearsheet=False
        )
    
        # Verify results
        assert results is not None
        assert len(strat_obj.prices) &gt; 0, "Expected to collect some prices"
        assert len(strat_obj.times) &gt; 0, "Expected to collect some timestamps"
    
        # Verify minute-level cadence (should have many data points over 2 days)
        # With minute data from 9:30 to 16:00 (6.5 hours = 390 minutes per day)
        # Over 2 days we should have roughly 780 minutes of trading
        assert len(strat_obj.prices) &gt; 100, f"Expected many minute-level data points, got {len(strat_obj.prices)}"
    
        # Verify all prices are valid numbers
        for price in strat_obj.prices:
&gt;           assert price is not None and price &gt; 0, f"Expected valid price, got {price}"
E           AssertionError: Expected valid price, got None
E           assert (None is not None)

tests/backtest/test_databento.py:103: AssertionError</failure></testcase><testcase classname="tests.backtest.test_databento.TestDatabentoBacktestFull" name="test_databento_continuous_futures_minute_data_polars" time="15.970" /><testcase classname="tests.backtest.test_databento.TestDatabentoBacktestFull" name="test_databento_daily_continuous_futures" time="6.512" /><testcase classname="tests.backtest.test_databento_comprehensive_trading.TestDatabentoComprehensiveTrading" name="test_multiple_instruments_minute_data" time="41.564" /><testcase classname="tests.backtest.test_databento_comprehensive_trading.TestDatabentoComprehensiveTradingDaily" name="test_multiple_instruments_daily_data" time="40.199" /><testcase classname="tests.backtest.test_debug_avg_fill_price" name="test_debug_avg_fill_price" time="8.316" /><testcase classname="tests.backtest.test_dividends.TestDividends" name="test_yahoo_finance_dividends" time="6.530" /><testcase classname="tests.backtest.test_dividends.TestDividends" name="test_polygon_dividends" time="4.093" /><testcase classname="tests.backtest.test_dividends.TestDividends" name="test_compare_yahoo_vs_polygon_dividends" time="7.841" /><testcase classname="tests.backtest.test_example_strategies.TestExampleStrategies" name="test_stock_bracket" time="0.398"><failure message="assert np.float64(0.0) &gt; 0">self = &lt;tests.backtest.test_example_strategies.TestExampleStrategies object at 0x11c276b70&gt;

    def test_stock_bracket(self):
        """
        Test the example strategy StockBracket by running a backtest and checking that the strategy object is returned
        along with the correct results
        """
    
        # Parameters
        backtesting_start = datetime.datetime(2023, 3, 3)
        backtesting_end = datetime.datetime(2023, 3, 10)
    
        # Execute Backtest
        results, strat_obj = StockBracket.run_backtest(
            YahooDataBacktesting,
            backtesting_start,
            backtesting_end,
            benchmark_asset=None,
            show_plot=False,
            show_tearsheet=False,
            save_tearsheet=False,
            show_indicators=False,
        )
        assert results
        assert isinstance(strat_obj, StockBracket)
        assert strat_obj.submitted_bracket_order is not None
    
        trades_df = strat_obj.broker._trade_event_log_df
    
        # Get all the filled limit orders
        filled_orders = trades_df[(trades_df["status"] == "fill")]
    
        # Check that the second order was a lmit order with a price of $405 or more and a quantity of 10
        assert filled_orders.iloc[1]["type"] == "limit"
        assert filled_orders.iloc[1]["filled_quantity"] == 10
        assert filled_orders.iloc[1]["price"] &gt;= 405
    
        all_orders = strat_obj.broker.get_all_orders()
        assert len(all_orders) == 3
        entry_order = [o for o in all_orders if o.order_type == Order.OrderType.MARKET][0]
        limit_order = [o for o in all_orders if o.order_type == Order.OrderType.LIMIT][0]
        stop_order = [o for o in all_orders if o.order_type == Order.OrderType.STOP][0]
    
        assert entry_order.quantity == 10
        assert limit_order.quantity == 10
        assert stop_order.quantity == 10
    
        assert strat_obj.submitted_bracket_order.is_filled(), "Should be same as entry order"
        assert entry_order.is_filled()
        assert limit_order.is_filled()
        assert stop_order.is_canceled()
    
        assert entry_order.get_fill_price() &gt; 1
        assert limit_order.get_fill_price() &gt;= 405
    
        buy_fill = filled_orders[filled_orders["side"] == "buy"].iloc[0]
        exit_fill = filled_orders[filled_orders["side"].str.startswith("sell")].iloc[0]
    
&gt;       assert buy_fill["trade_cost"] &gt; 0
E       assert np.float64(0.0) &gt; 0

tests/backtest/test_example_strategies.py:80: AssertionError</failure></testcase><testcase classname="tests.backtest.test_example_strategies.TestExampleStrategies" name="test_stock_oco" time="0.450" /><testcase classname="tests.backtest.test_example_strategies.TestExampleStrategies" name="test_stock_buy_and_hold" time="0.516"><failure message="assert np.float64(51.0) &gt;= 2500.0&#10; +  where np.float64(51.0) = round((np.float64(0.5095898201859943) * 100), 1)">self = &lt;tests.backtest.test_example_strategies.TestExampleStrategies object at 0x11c277020&gt;

    def test_stock_buy_and_hold(self):
        """
        Test the example strategy BuyAndHold by running a backtest and checking that the strategy object is returned
        along with the correct results
        """
    
        # Parameters
        backtesting_start = datetime.datetime(2023, 7, 10)
        backtesting_end = datetime.datetime(2023, 7, 13)
    
        # Execute Backtest
        results, strat_obj = BuyAndHold.run_backtest(
            YahooDataBacktesting,
            backtesting_start,
            backtesting_end,
            benchmark_asset=None,
            show_plot=False,
            show_tearsheet=False,
            show_indicators=False,
            save_tearsheet=False,
        )
        assert results
        assert isinstance(strat_obj, BuyAndHold)
    
        # Check that the results are correct
&gt;       assert round(results["cagr"] * 100, 1) &gt;= 2500.0
E       assert np.float64(51.0) &gt;= 2500.0
E        +  where np.float64(51.0) = round((np.float64(0.5095898201859943) * 100), 1)

tests/backtest/test_example_strategies.py:185: AssertionError</failure></testcase><testcase classname="tests.backtest.test_example_strategies.TestExampleStrategies" name="test_stock_diversified_leverage" time="1.108"><failure message="assert np.float64(2905.5) &gt;= 400000.0&#10; +  where np.float64(2905.5) = round((np.float64(29.05496137943266) * 100), 1)">self = &lt;tests.backtest.test_example_strategies.TestExampleStrategies object at 0x11c277260&gt;

    def test_stock_diversified_leverage(self):
        """
        Test the example strategy DiversifiedLeverage by running a backtest and checking that the strategy object is
        returned along with the correct results.
        """
    
        # Parameters
        backtesting_start = datetime.datetime(2023, 7, 10)
        backtesting_end = datetime.datetime(2023, 7, 13)
    
        # Execute Backtest
        results, strat_obj = DiversifiedLeverage.run_backtest(
            YahooDataBacktesting,
            backtesting_start,
            backtesting_end,
            benchmark_asset=None,
            show_plot=False,
            show_tearsheet=False,
            show_indicators=False,
            save_tearsheet=False,
        )
        assert results
        assert isinstance(strat_obj, DiversifiedLeverage)
    
        # Check that the results are correct
&gt;       assert round(results["cagr"] * 100, 1) &gt;= 400000.0
E       assert np.float64(2905.5) &gt;= 400000.0
E        +  where np.float64(2905.5) = round((np.float64(29.05496137943266) * 100), 1)

tests/backtest/test_example_strategies.py:214: AssertionError</failure></testcase><testcase classname="tests.backtest.test_example_strategies.TestExampleStrategies" name="test_limit_and_trailing_stops" time="0.423"><failure message="assert 0 == 1&#10; +  where 0 = len(Empty DataFrame\nColumns: [time, strategy, identifier, symbol, side, type, status, multiplier, time_in_force, asset.strike, asset.multiplier, asset.asset_type, price, filled_quantity, trade_cost]\nIndex: [])">self = &lt;tests.backtest.test_example_strategies.TestExampleStrategies object at 0x11c2774a0&gt;

    def test_limit_and_trailing_stops(self):
        """
        Test the example strategy LimitAndTrailingStop by running a backtest and checking that the strategy object is
        returned along with the correct results.
        """
    
        # Parameters
        backtesting_start = datetime.datetime(2023, 3, 3)
        backtesting_end = datetime.datetime(2023, 3, 10)
    
        # Execute Backtest
        results, strat_obj = LimitAndTrailingStop.run_backtest(
            YahooDataBacktesting,
            backtesting_start,
            backtesting_end,
            benchmark_asset=None,
            show_plot=False,
            show_tearsheet=False,
            show_indicators=False,
            save_tearsheet=False,
        )
    
        assert results
        assert isinstance(strat_obj, LimitAndTrailingStop)
    
        trades_df = strat_obj.broker._trade_event_log_df
        assert not trades_df.empty
    
        # Get all the filled limit orders
        filled_limit_orders = trades_df[(trades_df["status"] == "fill") &amp; (trades_df["type"] == "limit")]
    
        # The first limit order should have filled at $399.71 and a quantity of 100
        assert round(filled_limit_orders.iloc[0]["price"], 2) == 399.71
        assert filled_limit_orders.iloc[0]["filled_quantity"] == 100
    
        # The second limit order should have filled at $399.74 and a quantity of 100
        assert round(filled_limit_orders.iloc[1]["price"], 2) == 407
        assert filled_limit_orders.iloc[1]["filled_quantity"] == 100
    
        # Get all the filled trailing stop orders
        filled_trailing_stop_orders = trades_df[
            (trades_df["status"] == "fill") &amp; (trades_df["type"] == "trailing_stop")
        ]
    
        # Check if we have an order with a rounded price of 2 decimals of 400.45 and a quantity of 50
        order1 = filled_trailing_stop_orders[
            (round(filled_trailing_stop_orders["price"], 2) == 400.45)
            &amp; (filled_trailing_stop_orders["filled_quantity"] == 50)
        ]
&gt;       assert len(order1) == 1
E       assert 0 == 1
E        +  where 0 = len(Empty DataFrame\nColumns: [time, strategy, identifier, symbol, side, type, status, multiplier, time_in_force, asset.strike, asset.multiplier, asset.asset_type, price, filled_quantity, trade_cost]\nIndex: [])

tests/backtest/test_example_strategies.py:267: AssertionError</failure></testcase><testcase classname="tests.backtest.test_example_strategies.TestExampleStrategies" name="test_options_hold_to_expiry" time="0.589" /><testcase classname="tests.backtest.test_example_strategies.TestExampleStrategies" name="test_ccxt_backtesting" time="2.077"><failure message="duckdb.duckdb.SerializationException: Serialization Error: Failed to deserialize: expected end of object, but found field id: 100">self = &lt;tests.backtest.test_example_strategies.TestExampleStrategies object at 0x11c277a40&gt;

    def test_ccxt_backtesting(self):
        """
        Test the example strategy StockBracket by running a backtest and checking that the strategy object is returned
        along with the correct results
        """
    
        base_symbol = "ETH"
        quote_symbol = "USDT"
        # Shortened from 1-year backtest to 1-month backtest for faster testing
        backtesting_start = datetime.datetime(2023, 10, 1)
        backtesting_end = datetime.datetime(2023, 10, 31)
        asset = (Asset(symbol=base_symbol, asset_type="crypto"),
                Asset(symbol=quote_symbol, asset_type="crypto"))
    
        exchange_id = "kraken"  #"kucoin" #"bybit" #"okx" #"bitmex" # "binance"
    
        # CcxtBacktesting default data download limit is 50,000
        # If you want to change the maximum data download limit, you can do so by using 'max_data_download_limit'.
        kwargs = {
            # "max_data_download_limit":10000, # optional
            "exchange_id":exchange_id,
        }
        CcxtBacktesting.MIN_TIMESTEP = "day"
&gt;       results, strat_obj = CcxtBacktestingExampleStrategy.run_backtest(
            CcxtBacktesting,
            backtesting_start,
            backtesting_end,
            benchmark_asset=f"{base_symbol}/{quote_symbol}",
            show_plot=False,
            show_tearsheet=False,
            show_indicators=False,
            save_tearsheet=False,
            risk_free_rate=0.0,
            parameters={
            "asset":asset,
            "cash_at_risk":.25,
            "window":21},
            **kwargs
        )

tests/backtest/test_example_strategies.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;class 'lumibot.example_strategies.ccxt_backtesting_example.CcxtBacktestingExampleStrategy'&gt;
datasource_class = &lt;class 'lumibot.backtesting.ccxt_backtesting.CcxtBacktesting'&gt;
backtesting_start = datetime.datetime(2023, 10, 1, 0, 0, tzinfo=&lt;DstTzInfo 'America/New_York' EDT-1 day, 20:00:00 DST&gt;)
backtesting_end = datetime.datetime(2023, 10, 31, 0, 0, tzinfo=&lt;DstTzInfo 'America/New_York' EDT-1 day, 20:00:00 DST&gt;)
minutes_before_closing = 5, minutes_before_opening = 60, sleeptime = 1
stats_file = 'logs/CcxtBacktestingExampleStrategy_2025-10-05_16-30_0X3x4s_stats.csv'
risk_free_rate = 0.0, logfile = None, config = None, auto_adjust = False
name = 'CcxtBacktestingExampleStrategy', budget = None
benchmark_asset = 'ETH/USDT', analyze_backtest = True, plot_file_html = None
trades_file = None, settings_file = None, pandas_data = None, quote_asset = USD
starting_positions = None, show_plot = False, tearsheet_file = None
save_tearsheet = False, show_tearsheet = False
parameters = {'asset': (ETH, USDT), 'cash_at_risk': 0.25, 'window': 21}
buy_trading_fees = [], sell_trading_fees = []
polygon_api_key = 'fbzKxeskSamLjKi82NLrQPUvSzvlYVK0'
use_other_option_source = False, thetadata_username = 'rob@lumiwealth.com'
thetadata_password = 'x@t&amp;0&lt;M%Z70!pp*M*86J', indicators_file = None
show_indicators = False, save_logfile = False, use_quote_data = False
show_progress_bar = True, quiet_logs = True
trader_class = &lt;class 'lumibot.traders.trader.Trader'&gt;
include_cash_positions = False, save_stats_file = True
kwargs = {'exchange_id': 'kraken'}

    @classmethod
    def run_backtest(
        self,
        datasource_class,
        backtesting_start: datetime = None,
        backtesting_end: datetime = None,
        minutes_before_closing = 5,
        minutes_before_opening = 60,
        sleeptime = 1,
        stats_file = None,
        risk_free_rate = None,
        logfile = None,
        config = None,
        auto_adjust = False,
        name = None,
        budget = None,
        benchmark_asset: str | Asset | None="SPY",
        analyze_backtest: bool = True,
        plot_file_html = None,
        trades_file = None,
        settings_file = None,
        pandas_data: Union[List, Dict[Asset, Data]] = None,
        quote_asset = Asset(symbol="USD", asset_type="forex"),
        starting_positions = None,
        show_plot = None,
        tearsheet_file = None,
        save_tearsheet = True,
        show_tearsheet = None,
        parameters = {},
        buy_trading_fees = [],
        sell_trading_fees = [],
        polygon_api_key = None,
        use_other_option_source = False,
        thetadata_username = None,
        thetadata_password = None,
        indicators_file = None,
        show_indicators = None,
        save_logfile = False,
        use_quote_data = False,
        show_progress_bar = True,
        quiet_logs = False,
        trader_class = Trader,
        include_cash_positions=False,
        save_stats_file = True,
        **kwargs,
    ):
        """Backtest a strategy.
    
        Parameters
        ----------
        datasource_class : class
            The datasource class to use. For example, if you want to use the yahoo finance datasource,
            then you would pass YahooDataBacktesting as the datasource_class.
        backtesting_start : datetime
            The start date of the backtesting period.
        backtesting_end : datetime
            The end date of the backtesting period.
        minutes_before_closing : int
            The number of minutes before closing that the minutes_before_closing strategy method will be called.
        minutes_before_opening : int
            The number of minutes before opening that the minutes_before_opening strategy method will be called.
        sleeptime : int
            The number of seconds to sleep between each iteration of the backtest.
        stats_file : str
            The file to write the stats to.
        risk_free_rate : float
            The risk-free rate to use.
        logfile : str
            The file to write the log to.
        config : dict
            The config to use to set up the brokers in live trading.
        auto_adjust : bool
            Whether to automatically adjust the strategy.
        name : str
            The name of the strategy.
        budget : float
            The initial budget to use for the backtest.
        benchmark_asset : str or Asset or None
            The benchmark asset to use for the backtest to compare to. If it is a string then it will be converted
            to a stock Asset object. If it is None, no benchmarking will occur.
        analyze_backtest: bool = True
            Run the backtest_analysis method on the strategy.
        plot_file_html : str
            The file to write the plot html to.
        trades_file : str
            The file to write the trades to.
        pandas_data : list
            A list of Data objects that are used when the datasource_class object is set to PandasDataBacktesting.
            This contains all the data that will be used in backtesting.
        quote_asset : Asset (crypto)
            An Asset object for the cryptocurrency that will get used
            as a valuation asset for measuring overall porfolio values.
            Usually USDT, USD, USDC.
        starting_positions : dict
            A dictionary of starting positions for each asset. For example,
            if you want to start with $100 of SPY, and $200 of AAPL, then you
            would pass in starting_positions={'SPY': 100, 'AAPL': 200}.
        show_plot : bool
            Whether to show the plot.
        show_tearsheet : bool
            Whether to show the tearsheet.
        save_tearsheet : bool
            Whether to save the tearsheet.
        parameters : dict
            A dictionary of parameters to pass to the strategy. These parameters
            must be set up within the initialize() method.
        buy_trading_fees : list of TradingFee objects
            A list of TradingFee objects to apply to the buy orders during backtests.
        sell_trading_fees : list of TradingFee objects
            A list of TradingFee objects to apply to the sell orders during backtests.
        polygon_api_key : str
            The polygon api key to use for polygon data. Only required if you are using PolygonDataBacktesting as
            the datasource_class.
        indicators_file : str
            The file to write the indicators to.
        show_indicators : bool
            Whether to show the indicators plot.
        save_logfile : bool
            Whether to save the logfile. Defaults to False. If True, the logfile will be saved to the logs directory. Turning on this option will slow down the backtest.
        use_quote_data : bool
            Whether to use quote data for the backtest. Defaults to False. If True, the backtest will use quote data for the backtest. (Currently this is specific to ThetaData)
            When set to true this requests Quote data in addition to OHLC which adds time to backtests.
        show_progress_bar : bool
            Whether to show the progress bar during the backtest. Defaults to True.
        quiet_logs : bool
            Whether to quiet the logs during the backtest. Defaults to True.
        trader_class : class
            The class to use for the trader. Defaults to Trader.
    
        Returns
        -------
        tuple of (dict, Strategy)
            A tuple of the analysis dictionary and the strategy object. The analysis dictionary contains the
            analysis of the strategy returns. The strategy object is the strategy object that was backtested, where
            you can access the strategy returns and other attributes.
    
        Examples
        --------
    
        &gt;&gt;&gt; from datetime import datetime
        &gt;&gt;&gt; from lumibot.backtesting import YahooDataBacktesting
        &gt;&gt;&gt; from lumibot.strategies import Strategy
        &gt;&gt;&gt;
        &gt;&gt;&gt; # A simple strategy that buys AAPL on the first day
        &gt;&gt;&gt; class MyStrategy(Strategy):
        &gt;&gt;&gt;    def on_trading_iteration(self):
        &gt;&gt;&gt;        if self.first_iteration:
        &gt;&gt;&gt;            order = self.create_order("AAPL", quantity=1, side="buy")
        &gt;&gt;&gt;            self.submit_order(order)
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Create a backtest
        &gt;&gt;&gt; backtesting_start = datetime(2018, 1, 1)
        &gt;&gt;&gt; backtesting_end = datetime(2018, 1, 31)
        &gt;&gt;&gt;
        &gt;&gt;&gt; # The benchmark asset to use for the backtest to compare to
        &gt;&gt;&gt; benchmark_asset = Asset(symbol="QQQ", asset_type="stock")
        &gt;&gt;&gt;
        &gt;&gt;&gt; backtest = MyStrategy.backtest(
        &gt;&gt;&gt;     datasource_class=YahooDataBacktesting,
        &gt;&gt;&gt;     backtesting_start=backtesting_start,
        &gt;&gt;&gt;     backtesting_end=backtesting_end,
        &gt;&gt;&gt;     benchmark_asset=benchmark_asset,
        &gt;&gt;&gt; )
        """
    
        if name is None:
            name = self.__name__
    
        self._name = name
        self._analyze_backtest = analyze_backtest
    
        # Set backtesting_start: priority 1 - passed argument, 2 - BACKTESTING_START env var, 3 - default to 1 year ago
        if backtesting_start is not None:
            pass
        elif BACKTESTING_START is not None:
            backtesting_start = BACKTESTING_START
        else:
            backtesting_start = datetime.datetime.now() - datetime.timedelta(days=365)
            get_logger(__name__).warning(
            colored(
                "backtesting_start is set to one year ago by default. You can set it to a specific date by passing in the backtesting_start parameter or by setting the BACKTESTING_START environment variable.",
                "yellow"
            )
            )
    
        # Set backtesting_end: priority 1 - passed argument, 2 - BACKTESTING_END env var, 3 - default to yesterday
        if backtesting_end is not None:
            pass
        elif BACKTESTING_END is not None:
            backtesting_end = BACKTESTING_END
        else:
            backtesting_end = datetime.datetime.now() - datetime.timedelta(days=1)
            get_logger(__name__).warning(
            colored(
                "backtesting_end is set to the current date by default. You can set it to a specific date by passing in the backtesting_end parameter or by setting the BACKTESTING_END environment variable.",
                "yellow"
            )
            )
    
        # Create an adapter with 'strategy_name' set to the instance's name
        if not hasattr(self, "logger") or self.logger is None:
            self.logger = get_strategy_logger(__name__, self._name)
    
        # If show_plot is None, then set it to True
        if show_plot is None:
            show_plot = SHOW_PLOT
    
        # If show_tearsheet is None, then set it to True
        if show_tearsheet is None:
            show_tearsheet = SHOW_TEARSHEET
    
        # If show_indicators is None, then set it to True
        if show_indicators is None:
            show_indicators = SHOW_INDICATORS
    
        # Auto-select datasource from environment variable if None
        if datasource_class is None:
            from lumibot.credentials import BACKTESTING_DATA_SOURCE
            from lumibot.backtesting import (
                PolygonDataBacktesting,
                ThetaDataBacktesting,
                YahooDataBacktesting,
                AlpacaBacktesting,
                CcxtBacktesting,
                DataBentoDataBacktesting,
            )
    
            datasource_map = {
                "polygon": PolygonDataBacktesting,
                "thetadata": ThetaDataBacktesting,
                "yahoo": YahooDataBacktesting,
                "alpaca": AlpacaBacktesting,
                "ccxt": CcxtBacktesting,
                "databento": DataBentoDataBacktesting,
            }
    
            datasource_name = BACKTESTING_DATA_SOURCE.lower()
            if datasource_name not in datasource_map:
                raise ValueError(
                    f"Unknown BACKTESTING_DATA_SOURCE: '{BACKTESTING_DATA_SOURCE}'. "
                    f"Valid options: {list(datasource_map.keys())}"
                )
    
            datasource_class = datasource_map[datasource_name]
            get_logger(__name__).info(colored(
                f"Auto-selected backtesting data source from BACKTESTING_DATA_SOURCE env var: {BACKTESTING_DATA_SOURCE}",
                "green"
            ))
    
        # Make sure polygon_api_key is set if using PolygonDataBacktesting
        polygon_api_key = polygon_api_key if polygon_api_key is not None else POLYGON_API_KEY
        if datasource_class.__name__ == 'PolygonDataBacktesting' and polygon_api_key is None:
            raise ValueError(
                "Please set `POLYGON_API_KEY` to your API key from polygon.io as an environment variable if "
                "you are using PolygonDataBacktesting. If you don't have one, you can get a free API key "
                "from https://polygon.io/."
            )
    
        # Make sure thetadata_username and thetadata_password are set if using ThetaDataBacktesting
        if thetadata_username is None or thetadata_password is None:
            # Try getting the Theta Data credentials from credentials
            thetadata_username = THETADATA_CONFIG.get('THETADATA_USERNAME')
            thetadata_password = THETADATA_CONFIG.get('THETADATA_PASSWORD')
    
            # Check again if theta data username and pass are set (before checking dict)
            if datasource_class.__name__ == 'ThetaDataBacktesting' and (thetadata_username is None or thetadata_password is None):
                raise ValueError(
                    "Please set `thetadata_username` and `thetadata_password` in the backtest() function if "
                    "you are using ThetaDataBacktesting. If you don't have one, you can do registeration "
                    "from https://www.thetadata.net/."
                )
    
        # check if datasource_class is a class or a dictionary
        if isinstance(datasource_class, dict):
            optionsource_class = datasource_class["OPTION"]
            datasource_class = datasource_class["STOCK"]
            # check if optionsource_class and datasource_class are the same type of class
            if optionsource_class == datasource_class:
                use_other_option_source = False
            else:
                use_other_option_source = True
    
            # Check ThetaData credentials for optionsource_class after dict extraction
            if optionsource_class.__name__ == 'ThetaDataBacktesting' and (thetadata_username is None or thetadata_password is None):
                raise ValueError(
                    "Please set `thetadata_username` and `thetadata_password` in the backtest() function if "
                    "you are using ThetaDataBacktesting. If you don't have one, you can do registeration "
                    "from https://www.thetadata.net/."
                )
        else:
            optionsource_class = None
            use_other_option_source = False
    
        # Make a string with 6 random numbers/letters (upper and lowercase) to avoid overwriting
        random_string = "".join(random.choices(string.ascii_letters + string.digits, k=6))
    
        datestring = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M")
        base_filename = f"{name + '_' if name is not None else ''}{datestring}_{random_string}"
    
        logdir = "logs"
        if logfile is None and save_logfile:
            logfile = f"{logdir}/{base_filename}_logs.csv"
        if stats_file is None and save_stats_file:
            stats_file = f"{logdir}/{base_filename}_stats.csv"
    
        # #############################################
        # Check the data types of the parameters
        # #############################################
    
        # Check datasource_class
        if not isinstance(datasource_class, type):
            raise ValueError(f"`datasource_class` must be a class. You passed in {datasource_class}")
    
        # Check optionsource_class
        if use_other_option_source and not isinstance(optionsource_class, type):
            raise ValueError(f"`optionsource_class` must be a class. You passed in {optionsource_class}")
    
        self.verify_backtest_inputs(backtesting_start, backtesting_end)
    
        if not self.IS_BACKTESTABLE:
            get_logger(__name__).warning(f"Strategy {name + ' ' if name is not None else ''}cannot be " f"backtested at the moment")
            return None
    
        try:
            backtesting_start = to_datetime_aware(backtesting_start)
            backtesting_end = to_datetime_aware(backtesting_end)
        except AttributeError:
            get_logger(__name__).error(
                "`backtesting_start` and `backtesting_end` must be datetime objects. \n"
                "You are receiving this error most likely because you are using \n"
                "the original positional arguments for backtesting. \n\n"
            )
            return None
    
        if BACKTESTING_QUIET_LOGS is not None:
            quiet_logs = BACKTESTING_QUIET_LOGS
    
        if BACKTESTING_SHOW_PROGRESS_BAR is not None:
            show_progress_bar = BACKTESTING_SHOW_PROGRESS_BAR
    
        self._trader = trader_class(logfile=logfile, backtest=True, quiet_logs=quiet_logs)
    
        if datasource_class.__name__ == 'PolygonDataBacktesting':
            data_source = datasource_class(
                backtesting_start,
                backtesting_end,
                config=config,
                auto_adjust=auto_adjust,
                api_key=polygon_api_key,
                pandas_data=pandas_data,
                show_progress_bar=show_progress_bar,
                max_memory=POLYGON_MAX_MEMORY_BYTES,
                log_backtest_progress_to_file=LOG_BACKTEST_PROGRESS_TO_FILE,
                **kwargs,
            )
        elif datasource_class.__name__ == 'ThetaDataBacktesting' or (optionsource_class and optionsource_class.__name__ == 'ThetaDataBacktesting'):
            data_source = datasource_class(
                backtesting_start,
                backtesting_end,
                config=config,
                auto_adjust=auto_adjust,
                username=thetadata_username,
                password=thetadata_password,
                pandas_data=pandas_data,
                use_quote_data=use_quote_data,
                show_progress_bar=show_progress_bar,
                log_backtest_progress_to_file=LOG_BACKTEST_PROGRESS_TO_FILE,
                **kwargs,
            )
        elif datasource_class == InteractiveBrokersRESTBacktesting:
            data_source = datasource_class(
                backtesting_start,
                backtesting_end,
                config=INTERACTIVE_BROKERS_REST_CONFIG,
                auto_adjust=auto_adjust,
                pandas_data=pandas_data,
                show_progress_bar=show_progress_bar,
                log_backtest_progress_to_file=LOG_BACKTEST_PROGRESS_TO_FILE,
                **kwargs,
            )
        else:
            data_source = datasource_class(
                datetime_start=backtesting_start,
                datetime_end=backtesting_end,
                config=config,
                auto_adjust=auto_adjust,
                pandas_data=pandas_data,
                show_progress_bar=show_progress_bar,
                log_backtest_progress_to_file=LOG_BACKTEST_PROGRESS_TO_FILE,
                **kwargs,
            )
    
        if not use_other_option_source:
            backtesting_broker = BacktestingBroker(data_source)
        else:
            options_source = optionsource_class(
                backtesting_start,
                backtesting_end,
                config=config,
                auto_adjust=auto_adjust,
                username=thetadata_username,
                password=thetadata_password,
                pandas_data=pandas_data,
                show_progress_bar=show_progress_bar,
                **kwargs,
            )
            backtesting_broker = BacktestingBroker(data_source, options_source)
    
        strategy = self(
            backtesting_broker,
            minutes_before_closing=minutes_before_closing,
            minutes_before_opening=minutes_before_opening,
            sleeptime=sleeptime,
            risk_free_rate=risk_free_rate,
            stats_file=stats_file,
            benchmark_asset=benchmark_asset,
            analyze_backtest=analyze_backtest,
            backtesting_start=backtesting_start,
            backtesting_end=backtesting_end,
            pandas_data=pandas_data,
            quote_asset=quote_asset,
            starting_positions=starting_positions,
            name=name,
            budget=budget,
            parameters=parameters,
            buy_trading_fees=buy_trading_fees,
            sell_trading_fees=sell_trading_fees,
            save_logfile=save_logfile,
            include_cash_positions=include_cash_positions,
            **kwargs,
        )
        self._trader.add_strategy(strategy)
    
        self.logger.info("Starting backtest...")
        start = datetime.datetime.now()
    
&gt;       result = self._trader.run_all(
            show_plot=show_plot,
            show_tearsheet=show_tearsheet,
            save_tearsheet=save_tearsheet,
            show_indicators=show_indicators,
            tearsheet_file=tearsheet_file,
            base_filename=base_filename,
        )

lumibot/strategies/_strategy.py:1485: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lumibot.traders.trader.Trader object at 0x14095f4d0&gt;, async_ = False
show_plot = False, show_tearsheet = False, save_tearsheet = False
show_indicators = False, tearsheet_file = None
base_filename = 'CcxtBacktestingExampleStrategy_2025-10-05_16-30_0X3x4s'

    def run_all(
            self,
            async_=False,
            show_plot=True,
            show_tearsheet=True,
            save_tearsheet=True,
            show_indicators=True,
            tearsheet_file=None,
            base_filename=None,
            ):
        """
        run all strategies
    
        Parameters
        ----------
        async_: bool
            Whether to run the strategies asynchronously or not. This is not implemented yet.
    
        show_plot: bool
            Whether to disply the plot in the user's web browser. This is only used for backtesting.
    
        show_tearsheet: bool
            Whether to display the tearsheet in user's web browser. This is only used for backtesting.
    
        save_tearsheet: bool
            Whether to save the tearsheet or not. This is only used for backtesting.
    
        show_indicators: bool
            Whether to display the indicators (markers and lines) in the user's web browser. This is only used for backtesting.
    
        tearsheet_file: str
            The path to save the tearsheet. This is only used for backtesting.
    
        base_filename: str
            The base filename to save the tearsheet, plot, indicators, etc. This is only used for backtesting.
    
        Returns
        -------
        dict
            A dictionary with the keys being the strategy names and the values being the strategy analysis.
        """
        if not self._strategies:
            raise RuntimeError(
                "No strategies to run. You must call trader.add_strategy(strategy) " "before trader.run_all()."
            )
    
        if self.is_backtest_broker != self.backtest:
            raise RuntimeError(
                f"You cannot mix backtesting and live strategies. You passed in "
                f"Trader(backtest={self.backtest}) but the strategies are configured with "
                f"broker_backtesting={self.is_backtest_broker}."
            )
    
        if len(self._strategies) != 1:
            if self.is_backtest_broker:
                raise Exception(
                    f"Received {len(self._strategies)} strategies for backtesting."
                    f"You can only backtest one at a time."
                )
            else:
                raise NotImplementedError(
                    f"Running multiple live strategies is not implemented yet. You passed "
                    f"in {len(self._strategies)} strategies."
                )
    
        strat = self._strategies[0]
        # NOTE: Market auto-detection now happens inside Broker.__init__.
        # This previous redundancy has been removed to ensure a single
        # source of truth for market inference (futures / crypto / 24-7).
        if self.is_backtest_broker:
            strat.verify_backtest_inputs(strat.backtesting_start, strat.backtesting_end)
            logger.info("Backtesting starting...")
    
        signal.signal(signal.SIGINT, self._stop_pool)
        self._set_logger()
        self._init_pool()
        self._start_pool()
        if not async_:
&gt;           self._join_pool()

lumibot/traders/trader.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lumibot.traders.trader.Trader object at 0x14095f4d0&gt;

    def _join_pool(self):
        for strategy_thread in self._pool:
            strategy_thread.join()
    
        # For backtesting, check if any strategy failed and raise exception
        if self.is_backtest_broker:
            for strategy_thread in self._pool:
                # Check if the thread stored an exception
                if hasattr(strategy_thread, 'exception') and strategy_thread.exception is not None:
&gt;                   raise strategy_thread.exception

lumibot/traders/trader.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;StrategyExecutor(Thread-58, stopped daemon 13832826880)&gt;

    def run(self):
        try:
            # Overloading the broker sleep method
            self.broker.sleep = self.safe_sleep
    
            # Set the strategy name at the broker
            self.broker.set_strategy_name(self.strategy._name)
    
            self._initialize()
    
            # Get the trading days based on the market that the strategy is trading on
            market = self.broker.market
    
            # Initialize broker calendar and caches using trading days
            self.broker.initialize_market_calendars(get_trading_days(market))
    
            #####
            # Main strategy execution loop
            ####
    
            # Determine market type once to avoid repeated lookups
            market_name = getattr(self.broker, "market", None)
            is_continuous_market = market_name and self._is_continuous_market(market_name)
    
            while self.broker.should_continue() and self.should_continue:
                try:
                    self._run_trading_session()
    
                except Exception as e:
                    # The bot crashed so log the error, call the on_bot_crash method, and continue
                    self.strategy.logger.error(e)
                    self.strategy.logger.error(traceback.format_exc())
                    try:
                        self._on_bot_crash(e)
                    except Exception as e1:
                        self.strategy.logger.error(e1)
                        self.strategy.logger.error(traceback.format_exc())
    
                    # In BackTesting, we want to stop the bot if it crashes so there isn't an infinite loop
                    if self.strategy.is_backtesting:
&gt;                       raise e  # Re-raise original exception to preserve error message for tests
                        ^^^^^^^

lumibot/strategies/strategy_executor.py:1538: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;StrategyExecutor(Thread-58, stopped daemon 13832826880)&gt;

    def run(self):
        try:
            # Overloading the broker sleep method
            self.broker.sleep = self.safe_sleep
    
            # Set the strategy name at the broker
            self.broker.set_strategy_name(self.strategy._name)
    
            self._initialize()
    
            # Get the trading days based on the market that the strategy is trading on
            market = self.broker.market
    
            # Initialize broker calendar and caches using trading days
            self.broker.initialize_market_calendars(get_trading_days(market))
    
            #####
            # Main strategy execution loop
            ####
    
            # Determine market type once to avoid repeated lookups
            market_name = getattr(self.broker, "market", None)
            is_continuous_market = market_name and self._is_continuous_market(market_name)
    
            while self.broker.should_continue() and self.should_continue:
                try:
&gt;                   self._run_trading_session()

lumibot/strategies/strategy_executor.py:1524: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;StrategyExecutor(Thread-58, stopped daemon 13832826880)&gt;

    def _run_trading_session(self):
        """This is really intraday trading method. Timeframes of less than a day, seconds,
        minutes, hours.
        """
    
        has_data_source = hasattr(self.broker, "_data_source")
        market_name = getattr(self.broker, "market", None)
        is_continuous_market = market_name and self._is_continuous_market(market_name)
    
        # Process pandas daily and get out.
        if self._is_pandas_daily_data_source():
            self._process_pandas_daily_data()
            return
    
        # Set up market session and determine time_to_close
        if not is_continuous_market:
            # Set up market session and check if we should continue
            if not self._setup_market_session(has_data_source):
                return
            time_to_close = self.broker.get_time_to_close()
        else:
            time_to_close = float("inf")
    
        if not self.strategy.is_backtesting:
            # Start APScheduler for the trading session.
            self._setup_live_trading_scheduler()
    
            # Calculate if we should stop based on market timing
            should_we_stop = self._calculate_should_we_stop()
    
            # Clean up any existing check_queue thread before starting new one
            if hasattr(self, 'check_queue_thread') and self.check_queue_thread is not None:
                if self.check_queue_thread.is_alive():
                    self.check_queue_stop_event.set()
                    self.check_queue_thread.join(timeout=5.0)
    
            # Reset the stop event for the new thread
            self.check_queue_stop_event.clear()
    
            # Start the check_queue thread which will run continuously in the background, checking if any items have
            # been added to the queue and executing them.
            self.check_queue_thread = Thread(target=self.check_queue)
            self.check_queue_thread.start()
    
            next_run_time = self.get_next_ap_scheduler_run_time()
            if next_run_time is not None:
                # Format the date to be used in the log message.
                dt_str = next_run_time.strftime("%Y-%m-%d %I:%M:%S %p %Z")
                self.strategy.log_message(f"Strategy will check in again at: {dt_str}", color="blue")
    
            # Loop until the strategy should stop.
            loop_count = 0
            while True:
                loop_count += 1
    
                # Log every 60 iterations (roughly every minute) to track loop activity
                if loop_count % 60 == 1:
                    self.strategy.logger.debug(f"Main loop iteration #{loop_count} - Market closed status check")
    
                # Send data to cloud every minute FIRST - regardless of market status
                should_send_cloud_update = (not hasattr(self, '_last_updated_cloud')) or ((datetime.now() - self._last_updated_cloud) &gt;= timedelta(minutes=1))
                if should_send_cloud_update:
                    time_since_last = "never" if not hasattr(self, '_last_updated_cloud') else str(datetime.now() - self._last_updated_cloud)
                    self.strategy.logger.debug(f"Sending cloud update (last update: {time_since_last} ago)")
                    self.strategy.send_update_to_cloud()
                    self._last_updated_cloud = datetime.now()
    
                # Get the current jobs from the scheduler (may be None if gracefully exited previously)
                if self.scheduler is None:
                    self.strategy.log_message("⚠️ Scheduler is None, attempting to recreate", color="yellow")
                    # Attempt to re-create and start the scheduler
                    self._setup_live_trading_scheduler()
    
                jobs = self.scheduler.get_jobs() if self.scheduler is not None else []
    
                # Log scheduler status every minute
                if loop_count % 60 == 1:
                    self.strategy.logger.debug(f"Scheduler jobs: {len(jobs)} active")
    
                # Check if we should continue trading loop
                should_continue = self._should_continue_trading_loop(jobs, is_continuous_market, should_we_stop)
                if not should_continue:
                    self.strategy.logger.debug(f"Trading loop should stop: jobs={len(jobs)}, continuous={is_continuous_market}, should_stop={should_we_stop}")
                    break
    
                # Handle LifeCycle methods
                self._handle_lifecycle_methods()
    
                time.sleep(1)  # Sleep to save CPU
    
        #####
        # The main loop for backtesting if strategy is 24 hours
        ####
        # TODO: speed up this loop for backtesting (it's a major bottleneck)
    
        if self.strategy.is_backtesting:
&gt;           self._run_backtesting_loop(is_continuous_market, time_to_close)

lumibot/strategies/strategy_executor.py:1473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;StrategyExecutor(Thread-58, stopped daemon 13832826880)&gt;
is_continuous_market = True, time_to_close = inf

    def _run_backtesting_loop(self, is_continuous_market, time_to_close):
        """Execute the main backtesting iteration loop"""
        iteration_count = 0
    
        while is_continuous_market or (time_to_close is not None and (time_to_close &gt; self.strategy.minutes_before_closing * 60)):
            iteration_count += 1
    
            # Stop after we pass the backtesting end date
            if self.broker.IS_BACKTESTING_BROKER and self.broker.datetime &gt; self.broker.data_source.datetime_end:
                break
    
&gt;           self._on_trading_iteration()

lumibot/strategies/strategy_executor.py:1359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;StrategyExecutor(Thread-58, stopped daemon 13832826880)&gt;, args = ()
kwargs = {}

    @wraps(func_input)
    def func_output(self, *args, **kwargs):
        if self.should_continue:
            self._before_lifecycle_method()
&gt;           result = func_input(self, *args, **kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

lumibot/strategies/strategy_executor.py:554: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;StrategyExecutor(Thread-58, stopped daemon 13832826880)&gt;, args = ()
kwargs = {}
snapshot_before = {'asset': (ETH, USDT), 'backup_table_name': 'vars_backup', 'base': ETH, 'buy_trading_fees': [], ...}

    @wraps(func_input)
    def func_output(self, *args, **kwargs):
        self.strategy._update_portfolio_value()
        snapshot_before = self.strategy._copy_dict()
&gt;       result = func_input(self, *args, **kwargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

lumibot/strategies/strategy_executor.py:579: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;StrategyExecutor(Thread-58, stopped daemon 13832826880)&gt;

    @lifecycle_method
    @trace_stats
    def _on_trading_iteration(self):
        self._in_trading_iteration = True
    
        # If we are running live, we need to check if it's time to execute the trading iteration.
        if not self.strategy.is_backtesting:
            # Increase the cron count by 1.
            self.cron_count += 1
    
            # If the cron count is equal to the cron count target, reset the cron count to 0 and continue (execute
            # the on_trading_iteration method).
            if self.cron_count &gt;= self.cron_count_target:
                self.cron_count = 0
            else:
                # If the cron count is not equal to the cron count target, return and do not execute the
                # on_trading_iteration method.
                return
    
        # Check if self.strategy.sleeptime is a number or a string.
        if isinstance(self.strategy.sleeptime, (int, float)):
            sleep_units = "m"
        else:
            sleep_units = self.strategy.sleeptime[-1].lower()
        start_dt = datetime.now()
        self.sync_broker()
    
        # Check if we are in market hours.
        if not self.broker.is_market_open():
            if not self._market_closed_logged:
                self.strategy.log_message("The market is not currently open, skipping this trading iteration", color="blue")
                self._market_closed_logged = True
            return
        else:
            self._market_closed_logged = False  # Reset when market opens
    
        # Send the account summary to Discord
        self.strategy.send_account_summary_to_discord()
    
        self._strategy_context = None
        # Optimization: Use astimezone instead of localize for better performance
        # datetime.now() already returns a naive datetime, so we can use astimezone
        # This avoids the expensive localize operation that's called 355k times
        if start_dt.tzinfo is None:
            # If naive, use the faster replace+astimezone approach
            start_dt_tz = start_dt.replace(tzinfo=LUMIBOT_DEFAULT_PYTZ)
        else:
            # If already has timezone, just convert
            start_dt_tz = start_dt.astimezone(LUMIBOT_DEFAULT_PYTZ)
        start_str = start_dt_tz.strftime("%Y-%m-%d %I:%M:%S %p %Z")
        self.strategy.log_message(f"Bot is running. Executing the on_trading_iteration lifecycle method at {start_str}", color="green")
        on_trading_iteration = append_locals(self.strategy.on_trading_iteration)
    
        # Time-consuming
        try:
            # Variable Restore
            self.strategy.load_variables_from_db()
            on_trading_iteration()
    
            self.strategy._first_iteration = False
            self.broker._first_iteration = False
            self._strategy_context = on_trading_iteration.locals
            self.strategy._last_on_trading_iteration_datetime = datetime.now()
            self.process_queue()
    
            end_dt = datetime.now()
            end_dt_tz = LUMIBOT_DEFAULT_PYTZ.localize(end_dt.replace(tzinfo=None))
            end_str = end_dt_tz.strftime("%Y-%m-%d %I:%M:%S %p %Z")
            runtime = (end_dt - start_dt).total_seconds()
    
            # Variable Backup
            self._in_trading_iteration = False
            self.strategy.backup_variables_to_db()
    
            # Update cron count to account for how long this iteration took to complete so that the next iteration will
            # occur at the correct time.
            self.cron_count = self._seconds_to_sleeptime_count(int(runtime), sleep_units)
            next_run_time = self.get_next_ap_scheduler_run_time()
            if next_run_time is not None:
                # Format the date to be used in the log message.
                dt_str = next_run_time.strftime("%Y-%m-%d %I:%M:%S %p %Z")
                self.strategy.log_message(
                    f"Trading iteration ended at {end_str}, next check in time is {dt_str}. Took {runtime:.2f}s", color="blue"
                )
    
            else:
                self.strategy.log_message(f"Trading iteration ended at {end_str}", color="blue")
        except Exception as e:
            # If backtesting, raise the exception
            if self.broker.IS_BACKTESTING_BROKER:
&gt;               raise e

lumibot/strategies/strategy_executor.py:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;StrategyExecutor(Thread-58, stopped daemon 13832826880)&gt;

    @lifecycle_method
    @trace_stats
    def _on_trading_iteration(self):
        self._in_trading_iteration = True
    
        # If we are running live, we need to check if it's time to execute the trading iteration.
        if not self.strategy.is_backtesting:
            # Increase the cron count by 1.
            self.cron_count += 1
    
            # If the cron count is equal to the cron count target, reset the cron count to 0 and continue (execute
            # the on_trading_iteration method).
            if self.cron_count &gt;= self.cron_count_target:
                self.cron_count = 0
            else:
                # If the cron count is not equal to the cron count target, return and do not execute the
                # on_trading_iteration method.
                return
    
        # Check if self.strategy.sleeptime is a number or a string.
        if isinstance(self.strategy.sleeptime, (int, float)):
            sleep_units = "m"
        else:
            sleep_units = self.strategy.sleeptime[-1].lower()
        start_dt = datetime.now()
        self.sync_broker()
    
        # Check if we are in market hours.
        if not self.broker.is_market_open():
            if not self._market_closed_logged:
                self.strategy.log_message("The market is not currently open, skipping this trading iteration", color="blue")
                self._market_closed_logged = True
            return
        else:
            self._market_closed_logged = False  # Reset when market opens
    
        # Send the account summary to Discord
        self.strategy.send_account_summary_to_discord()
    
        self._strategy_context = None
        # Optimization: Use astimezone instead of localize for better performance
        # datetime.now() already returns a naive datetime, so we can use astimezone
        # This avoids the expensive localize operation that's called 355k times
        if start_dt.tzinfo is None:
            # If naive, use the faster replace+astimezone approach
            start_dt_tz = start_dt.replace(tzinfo=LUMIBOT_DEFAULT_PYTZ)
        else:
            # If already has timezone, just convert
            start_dt_tz = start_dt.astimezone(LUMIBOT_DEFAULT_PYTZ)
        start_str = start_dt_tz.strftime("%Y-%m-%d %I:%M:%S %p %Z")
        self.strategy.log_message(f"Bot is running. Executing the on_trading_iteration lifecycle method at {start_str}", color="green")
        on_trading_iteration = append_locals(self.strategy.on_trading_iteration)
    
        # Time-consuming
        try:
            # Variable Restore
            self.strategy.load_variables_from_db()
&gt;           on_trading_iteration()

lumibot/strategies/strategy_executor.py:695: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (), kwargs = {}

    @wraps(func_input)
    def func_output(*args, **kwargs):
&gt;       frame, result = call_function_get_frame(func_input, *args, **kwargs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

lumibot/tools/decorators.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

func = &lt;bound method CcxtBacktestingExampleStrategy.on_trading_iteration of &lt;lumibot.example_strategies.ccxt_backtesting_example.CcxtBacktestingExampleStrategy object at 0x11d98e570&gt;&gt;
args = (), kwargs = {}
wrapper = &lt;function CcxtBacktestingExampleStrategy.on_trading_iteration at 0x1515809a0&gt;

    def call_function_get_frame(func, *args, **kwargs):
        """
        Calls func and returns its local frame and result,
        much faster than using sys.settrace.
        """
    
        trace = sys.gettrace()
        frame = None
    
        if trace is None:
            # No debugger attached → use inspect for speed
            @wraps(func)
            def wrapper(*args, **kwargs):
                nonlocal frame
                frame = inspect.currentframe()
                return func(*args, **kwargs)
    
&gt;           result = wrapper(*args, **kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^

lumibot/tools/decorators.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (), kwargs = {}

    @wraps(func)
    def wrapper(*args, **kwargs):
        nonlocal frame
        frame = inspect.currentframe()
&gt;       return func(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^

lumibot/tools/decorators.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lumibot.example_strategies.ccxt_backtesting_example.CcxtBacktestingExampleStrategy object at 0x11d98e570&gt;

    def on_trading_iteration(self):
        # During the backtest, we get the current time with self.get_datetime().
        # The time interval is self.sleeptime.
        current_dt = self.get_datetime()
        cash, last_price, quantity = self._position_sizing()
&gt;       history_df = self._get_historical_prices()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

lumibot/example_strategies/ccxt_backtesting_example.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lumibot.example_strategies.ccxt_backtesting_example.CcxtBacktestingExampleStrategy object at 0x11d98e570&gt;

    def _get_historical_prices(self):
&gt;       return self.get_historical_prices(asset=self.asset,length=self.window,
                                    timestep="day",quote=self.quote).df

lumibot/example_strategies/ccxt_backtesting_example.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lumibot.example_strategies.ccxt_backtesting_example.CcxtBacktestingExampleStrategy object at 0x11d98e570&gt;
asset = (ETH, USDT), length = 21, timestep = 'day', timeshift = None
quote = USDT, exchange = None, include_after_hours = True, return_polars = False

    def get_historical_prices(
        self,
        asset: Union[Asset, str],
        length: int,
        timestep: str = "",
        timeshift: datetime.timedelta = None,
        quote: Asset = None,
        exchange: str = None,
        include_after_hours: bool = True,
        return_polars: bool = False,
    ):
        """Get historical pricing data for a given symbol or asset.
    
        Return data bars for a given symbol or asset.  Any number of bars can
        be return limited by the data available. This is set with 'length' in
        number of bars. Bars may be returned as daily or by minute. And the
        starting point can be shifted backwards by time or bars.
    
        Parameters
        ----------
        asset : str or Asset
            The symbol string representation (e.g. AAPL, GOOG, ...) or asset
            object. Cryptocurrencies must also specify the quote currency.
        length : int
            The number of rows (number of timesteps)
        timestep : str
            Time interval for each bar. Supports multiple formats:
    
            **Basic formats:**
                - ``"minute"`` or ``"day"`` - Single minute or day bars
    
            **Multi-timeframe formats (automatically aggregated):**
                - Minutes: ``"5min"``, ``"5m"``, ``"5 minutes"``, ``"15min"``, ``"30m"``, etc.
                - Hours: ``"1h"``, ``"1hour"``, ``"2h"``, ``"4 hours"``, etc. (converted to minutes)
                - Days: ``"2d"``, ``"2 days"``, ``"1 week"``, ``"1w"``, etc.
                - Flexible formatting: Case-insensitive, with/without spaces
    
            When using multi-timeframe formats, the method automatically fetches the
            underlying minute or day data and resamples it to your desired timeframe.
            Default value depends on the data_source (minute for alpaca, day for yahoo, ...)
        timeshift : timedelta
            ``None`` by default. If specified indicates the time shift from
            the present. If  backtesting in Pandas, use integer representing
            number of bars.
        quote : Asset
            The quote currency for crypto currencies (e.g. USD, USDT, EUR, ...).
            Default is the quote asset for the strategy.
        exchange : str
            The exchange to pull the historical data from. Default is None (decided based on the broker)
        include_after_hours : bool
            Whether to include after hours data. Default is True. Currently only works with Interactive Brokers.
        return_polars : bool
            If True, return Bars with Polars DataFrame for better performance. Default is False (returns pandas).
            When False and data is in Polars format, a warning will be issued about the conversion.
    
        Returns
        -------
        Bars
            The bars object with all the historical pricing data. Please check the ``Entities.Bars``
            object documentation for more details on how to use Bars objects. To get a ``DataFrame``
            from the Bars object, use ``bars.df``.
    
        Example
        -------
        Extract 2 rows of SPY data with one day timestep between each row
        with the latest data being 24h ago (timedelta(days=1)) (in a backtest)
    
        &gt;&gt;&gt; # Get the data for SPY for the last 2 days
        &gt;&gt;&gt; bars =  self.get_historical_prices("SPY", 2, "day")
        &gt;&gt;&gt; # To get the DataFrame of SPY data
        &gt;&gt;&gt; df = bars.df
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Then, to get the DataFrame of SPY data
        &gt;&gt;&gt; df = bars.df
        &gt;&gt;&gt; last_ohlc = df.iloc[-1] # Get the last row of the DataFrame (the most recent pricing data we have)
        &gt;&gt;&gt; self.log_message(f"Last price of BTC in USD: {last_ohlc['close']}, and the open price was {last_ohlc['open']}")
    
        &gt;&gt;&gt; # Get the data for AAPL for the last 30 minutes
        &gt;&gt;&gt; bars =  self.get_historical_prices("AAPL", 30, "minute")
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Then, to get the DataFrame of SPY data
        &gt;&gt;&gt; df = bars.df
        &gt;&gt;&gt; last_ohlc = df.iloc[-1] # Get the last row of the DataFrame (the most recent pricing data we have)
        &gt;&gt;&gt; self.log_message(f"Last price of AAPL: {last_ohlc['close']}, and the open price was {last_ohlc['open']}")
    
        &gt;&gt;&gt; # Get 5-minute bars for the last 10 5-minute periods (using new multi-timeframe support)
        &gt;&gt;&gt; bars = self.get_historical_prices("SPY", 10, "5min")
        &gt;&gt;&gt; df = bars.df  # DataFrame with 10 rows of 5-minute OHLCV data
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Get hourly bars for the last 24 hours
        &gt;&gt;&gt; bars = self.get_historical_prices("AAPL", 24, "1h")
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Get 15-minute bars (multiple format options work)
        &gt;&gt;&gt; bars = self.get_historical_prices("TSLA", 20, "15m")       # Short format
        &gt;&gt;&gt; bars = self.get_historical_prices("TSLA", 20, "15min")     # Alternative
        &gt;&gt;&gt; bars = self.get_historical_prices("TSLA", 20, "15 minutes") # With space
    
        &gt;&gt;&gt; # Get the historical data for an AAPL option for the last 30 minutes
        &gt;&gt;&gt; asset = self.create_asset("AAPL", asset_type="option", expiration=datetime.datetime(2020, 1, 1), strike=100, right="call")
        &gt;&gt;&gt; bars =  self.get_historical_prices(asset, 30, "minute")
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Then, to get the DataFrame of SPY data
        &gt;&gt;&gt; df = bars.df
        &gt;&gt;&gt; last_ohlc = df.iloc[-1] # Get the last row of the DataFrame (the most recent pricing data we have)
        &gt;&gt;&gt; self.log_message(f"Last price of BTC in USD: {last_ohlc['close']}, and the open price was {last_ohlc['open']}")
    
    
        &gt;&gt;&gt; # Get the data for BTC in USD  for the last 2 days
        &gt;&gt;&gt; asset_base = self.create(symbol="BTC", asset_type="crypto"),
        &gt;&gt;&gt; asset_quote = self.create(symbol="USDT", asset_type="crypto"),
        &gt;&gt;&gt;
        &gt;&gt;&gt; bars =  self.get_historical_prices(asset_base, 2, "day", quote=asset_quote)
        &gt;&gt;&gt;
        &gt;&gt;&gt; # Then, to get the DataFrame of SPY data
        &gt;&gt;&gt; df = bars.df
        &gt;&gt;&gt; last_ohlc = df.iloc[-1] # Get the last row of the DataFrame (the most recent pricing data we have)
        &gt;&gt;&gt; self.log_message(f"Last price of BTC in USD: {last_ohlc['close']}, and the open price was {last_ohlc['open']}")
        """
    
        # Get that length is type int and if not try to cast it
        if not isinstance(length, int):
            try:
                length = int(length)
            except Exception:
                raise ValueError(
                    f"Invalid length parameter in get_historical_prices() method. Length must be an int but instead got {length}, "
                    f"which is a type {type(length)}."
                )
    
        if quote is None:
            quote = self.quote_asset
    
        # Parse timestep to check if we need to aggregate
        original_timestep = timestep
        parsed = self._parse_timestep(timestep) if timestep else None
    
        # Determine the actual timestep to use for data fetching
        if parsed and parsed[0] &gt; 1:
            # Multi-timeframe request detected
            multiplier, base_unit = parsed
            actual_timestep = base_unit
            actual_length = length * multiplier
            needs_resampling = True
        elif parsed:
            # Standard format (1 minute or 1 day)
            multiplier, base_unit = parsed
            actual_timestep = base_unit
            actual_length = length
            needs_resampling = False
        else:
            # Use original timestep if parsing failed or empty
            actual_timestep = timestep if timestep else None
            actual_length = length
            needs_resampling = False
    
        # Only log once per asset to reduce noise
        asset_key = f"{asset}_{length}_{original_timestep}"
        if asset_key not in self._logged_get_historical_prices_assets:
            if needs_resampling:
                self.logger.info(f"Getting historical prices for {asset}, {length} bars of {original_timestep} (fetching {actual_length} {actual_timestep} bars)")
            else:
                self.logger.info(f"Getting historical prices for {asset}, {length} bars, {original_timestep}")
            self._logged_get_historical_prices_assets.add(asset_key)
    
        asset = self._sanitize_user_asset(asset)
    
        asset = self.crypto_assets_to_tuple(asset, quote)
        if not actual_timestep:
            actual_timestep = self.broker.data_source.get_timestep()
        # Call through to the appropriate data source. Only pass `return_polars` if supported
        # to maintain compatibility with live data sources that don't yet accept it.
        import inspect
    
        def _call_get_hist(ds):
            fn = ds.get_historical_prices
            params = inspect.signature(fn).parameters
            supports_return_polars = (
                "return_polars" in params
                or any(p.kind == inspect.Parameter.VAR_KEYWORD for p in params.values())
            )
    
            common_kwargs = dict(
                timestep=actual_timestep,  # Use the actual timestep for fetching
                timeshift=timeshift,
                exchange=exchange,
                include_after_hours=include_after_hours,
                quote=quote,
            )
            if supports_return_polars:
                return fn(
                    asset,
                    actual_length,  # Use the actual length for fetching
                    return_polars=return_polars,
                    **common_kwargs,
                )
            else:
                return fn(
                    asset,
                    actual_length,  # Use the actual length for fetching
                    **common_kwargs,
                )
    
        # Get the raw data
        if self.broker.option_source and asset.asset_type == "option":
            bars = _call_get_hist(self.broker.option_source)
        else:
&gt;           bars = _call_get_hist(self.broker.data_source)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

lumibot/strategies/strategy.py:3558: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ds = &lt;lumibot.backtesting.ccxt_backtesting.CcxtBacktesting object at 0x147d827b0&gt;

    def _call_get_hist(ds):
        fn = ds.get_historical_prices
        params = inspect.signature(fn).parameters
        supports_return_polars = (
            "return_polars" in params
            or any(p.kind == inspect.Parameter.VAR_KEYWORD for p in params.values())
        )
    
        common_kwargs = dict(
            timestep=actual_timestep,  # Use the actual timestep for fetching
            timeshift=timeshift,
            exchange=exchange,
            include_after_hours=include_after_hours,
            quote=quote,
        )
        if supports_return_polars:
            return fn(
                asset,
                actual_length,  # Use the actual length for fetching
                return_polars=return_polars,
                **common_kwargs,
            )
        else:
&gt;           return fn(
                asset,
                actual_length,  # Use the actual length for fetching
                **common_kwargs,
            )

lumibot/strategies/strategy.py:3548: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lumibot.backtesting.ccxt_backtesting.CcxtBacktesting object at 0x147d827b0&gt;
asset = (ETH, USDT), length = 21, timestep = 'day', timeshift = None
quote = USDT, exchange = None, include_after_hours = True

    def get_historical_prices(self, asset:tuple[Asset,Asset], length:int, timestep:str=None,
            timeshift:int=None, quote:Asset=None, exchange:Any=None, include_after_hours:bool=True
    )-&gt;Bars:
        """Get bars for a given asset"""
        if isinstance(asset, str):
            asset = Asset(symbol=asset,asset_type="crypto")
    
        if not timestep:
            timestep = self.get_timestep()
    
&gt;       response = self._pull_source_symbol_bars(
            asset,
            length,
            timestep=timestep,
            timeshift=timeshift,
            quote=quote,
            exchange=exchange,
            include_after_hours=include_after_hours,
        )

lumibot/data_sources/ccxt_backtesting_data.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lumibot.backtesting.ccxt_backtesting.CcxtBacktesting object at 0x147d827b0&gt;
asset = (ETH, USDT), length = 21, timestep = 'day', timeshift = None
quote = USDT, exchange = None, include_after_hours = True

    def _pull_source_symbol_bars(
        self, asset:tuple[Asset,Asset], length:int = None, timestep:str=MIN_TIMESTEP,
            timeshift:int=None, quote=Asset, exchange:Any=None, include_after_hours:bool=True
    )-&gt;Union[DataFrame,None]:
        """Gets the OHCLV data for a specific asset.
    
        Args:
            asset (tuple[Asset,Asset]): base asset and quote asset
                                        ex) (Asset(symbol="SOL",asset_type="crypto"),Asset(symbol="USDT",asset_type="crypto"))
            length (int, optional): Number of data to import. Defaults to None.
            timestep (str, optional): "day", "minute". Defaults to "minute".
            timeshift (int, optional): The amount of shift for a given datetime. Defaults to None.
            quote (Asset, optional): quote asset. Defaults to Asset.
            exchange (Any, optional): exchange. Defaults to None.
            include_after_hours (bool, optional): include_after_hours. Defaults to True.
    
        Returns:
            DataFrame: candle data
        """
        if exchange is not None:
            logger.warning(
                f"the exchange parameter is not implemented for CcxtData, but {exchange} was passed as the exchange"
            )
    
        if isinstance(asset, tuple):
            symbol = f"{asset[0].symbol.upper()}/{asset[1].symbol.upper()}"
        elif quote is not None:
            symbol = f"{asset.symbol.upper()}/{quote.symbol.upper()}"
        else:
            symbol = asset
    
        parsed_timestep = self._parse_source_timestep(timestep, reverse=True)
        symbol_timestep = f"{symbol}_{parsed_timestep}"
        if symbol_timestep in self._data_store:
            data = self._data_store[symbol_timestep]
        else:
&gt;           data = self._pull_source_bars([asset],length,timestep,timeshift,quote,include_after_hours)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

lumibot/data_sources/ccxt_backtesting_data.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lumibot.backtesting.ccxt_backtesting.CcxtBacktesting object at 0x147d827b0&gt;
assets = [(ETH, USDT)], length = 21, timestep = 'day', timeshift = None
quote = USDT, include_after_hours = True

    def _pull_source_bars(
            self,
            assets: tuple[Asset,Asset],
            length: int,
            timestep: str = MIN_TIMESTEP,
            timeshift: int = None,
            quote: Asset = None,
            include_after_hours: bool = False
    ) -&gt; Dict:
        """pull broker bars for a list assets"""
        parsed_timestep = self._parse_source_timestep(timestep, reverse=True)
    
        result = {}
        for asset in assets:
            if isinstance(asset, tuple):
                symbol = f"{asset[0].symbol.upper()}/{asset[1].symbol.upper()}"
            elif quote is not None:
                symbol = f"{asset.symbol.upper()}/{quote.symbol.upper()}"
            else:
                symbol = asset
    
            # convert native timezone aware
            start_dt = self._to_utc_timezone(self.datetime_start)
            end_dt = self._to_utc_timezone(self.datetime_end)
    
            if parsed_timestep == "1d":
                start_dt = start_dt - timedelta(days=self._download_start_dt_prebuffer)
            else:
                start_dt = start_dt - timedelta(minutes=self._download_start_dt_prebuffer)
    
&gt;           data = self.cache_db.download_ohlcv(
                symbol,parsed_timestep,
                start_dt,
                end_dt
            )

lumibot/data_sources/ccxt_backtesting_data.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lumibot.tools.ccxt_data_store.CcxtCacheDB object at 0x14bb6f2f0&gt;
symbol = 'ETH/USDT', timeframe = '1d'
start = datetime.datetime(2022, 12, 5, 4, 0, tzinfo=&lt;UTC&gt;)
end = datetime.datetime(2023, 10, 31, 3, 59, tzinfo=&lt;UTC&gt;), limit = 50000

    def download_ohlcv(self, symbol:str,timeframe:str,
                       start:datetime, end:datetime,  limit:int=None)-&gt;DataFrame:
        """Download data according to the given symbol, timeframe, start, end, and limit.
        Store the downloaded data in a cache.
        Data that is not in the cache is downloaded using CCXT.
        If a cache file exists, but the requested data range is not in the cache file, the data will be fetched using ccxt.
        For example, if the cache file contains data from 2023-01-01 to 2023-01-10, and you request data from 2023-01-05 to 2023-01-15,
        the data from 2023-01-05 to 2023-01-10 will be fetched from the cache file, and the data from 2023-01-11 to 2023-01-15 will be fetched using ccxt.
        The newly fetched data is stored in the cache file and the range of data stored in the cache file is updated to 2023-01-05 ~ 2023-01-15.
    
        Args:
            symbol (str):  BTC/USDT, ETH/USDT etc.
            timeframe (str): 1m, 1d etc.
            start (datetime): datetime object, ex) datetime(2023, 3, 2), datetime(2023, 3, 2, 12, 1, 0, 0)
            end (datetime): datetime object, ex) datetime(2023, 3, 4), datetime(2023, 3, 4, 10, 14, 0, 0)
            limit (int, optional): max download limit. Defaults to None.
    
        Raises:
            Exception: Raise an exception if the max download limit is exceeded.
    
        Returns:
            DataFrame: Data fetched from cache.
                       Use datetime as the index.
                       datetime, open, high, low, close, volume, missing columns.
        """
        if end is None:
            end = datetime.utcnow()
    
        if limit is None:
            limit = self.max_download_limit
    
        start_dt = start.replace(tzinfo=None)
        end_dt = end.replace(tzinfo=None)
    
        # set start_dt to 00:00:00 and end_dt to 23:59:59
        start_dt = start_dt.replace(hour=0, minute=0, second=0, microsecond=0)
        end_dt = end_dt.replace(hour=23, minute=59, second=59, microsecond=999999)
    
&gt;       download_ranges,overap_range_ids,cache_range = self._calc_download_ranges(symbol, timeframe,start_dt, end_dt)
                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

lumibot/tools/ccxt_data_store.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;lumibot.tools.ccxt_data_store.CcxtCacheDB object at 0x14bb6f2f0&gt;
symbol = 'ETH/USDT', timeframe = '1d'
start = datetime.datetime(2022, 12, 5, 0, 0)
end = datetime.datetime(2023, 10, 31, 23, 59, 59, 999999)

    def _calc_download_ranges(self,symbol:str,timeframe:str,
                             start:datetime,
                             end:datetime)-&gt;tuple[list[tuple[datetime, datetime]],list[str]]:
        """Checks for duplicates between the data stored in the cache and the requested data,
        and returns a range of non-duplicate download data ranges, overap ranges ids, new cache range.
        For example, suppose you have the following data ranges stored in cache
        ----------------------------------
        | id |   start_dt   |   end_dt   |
        ----------------------------------
        | id1 | 2023-01-01 | 2023-01-10  |
        | id2 | 2023-02-03 | 2023-03-11  |
        | id3 | 2023-05-01 | 2023-06-07  |
        ----------------------------------
    
        If the requested data is 2023-01-05 to 2023-03-07, return 2023-01-11 to 2023-02-02 as the new download range,
        overlapping range ids returns [id1,id2].
        And the new cache_range returns (2023-01-01,2023-03-11).
    
        Args:
            symbol (str): BTC/USDT, ETH/USDT etc.
            timeframe (str): 1m, 1d etc.
            start (datetime): datetime object,
                  ex) datetime(2023, 1, 5), datetime(2023, 1, 5, 12, 1, 0, 0)
            end (datetime): datetime object,
                  ex) datetime(2023, 3, 7), datetime(2023, 3, 7, 10, 14, 0, 0)
    
        Returns:
            tuple[list[tuple[datetime, datetime]],list[str]]: (new download ranges,overap range ids,new cache range)
        """
        cache_file = self.get_cache_file_name(symbol, timeframe)
        if not os.path.exists(cache_file):
            return [(start, end)],[],(start, end)
        if os.path.exists(cache_file):
            # get cache data ranges (id, start_dt, end_dt)
&gt;           with duckdb.connect(cache_file) as con:
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           duckdb.duckdb.SerializationException: Serialization Error: Failed to deserialize: expected end of object, but found field id: 100

lumibot/tools/ccxt_data_store.py:274: SerializationException</failure></testcase><testcase classname="tests.backtest.test_failing_backtest.TestFailingBacktest" name="test_initialize_failure_raises_exception" time="0.300" /><testcase classname="tests.backtest.test_failing_backtest.TestFailingBacktest" name="test_trading_iteration_failure_raises_exception" time="8.687" /><testcase classname="tests.backtest.test_failing_backtest.TestFailingBacktest" name="test_backtest_classmethod_initialize_failure" time="0.308" /><testcase classname="tests.backtest.test_failing_backtest.TestFailingBacktest" name="test_backtest_classmethod_trading_iteration_failure" time="14.601" /><testcase classname="tests.backtest.test_futures_edge_cases.TestFuturesEdgeCases" name="test_short_selling" time="8.344" /><testcase classname="tests.backtest.test_futures_edge_cases.TestFuturesEdgeCases" name="test_multiple_simultaneous_positions" time="12.841" /><testcase classname="tests.backtest.test_futures_single_trade.TestFuturesSingleTrade" name="test_single_mes_trade_tracking" time="8.337" /><testcase classname="tests.backtest.test_futures_ultra_simple" name="test_ultra_simple_buy_hold_sell" time="11.133" /><testcase classname="tests.backtest.test_index_data_verification.TestIndexDataVerification" name="test_spx_data_accessible" time="0.397" /><testcase classname="tests.backtest.test_index_data_verification.TestIndexDataVerification" name="test_vix_data_accessible" time="0.386" /><testcase classname="tests.backtest.test_index_data_verification.TestIndexDataVerification" name="test_index_timestamp_accuracy" time="0.383" /><testcase classname="tests.backtest.test_index_data_verification.TestIndexDataVerification" name="test_spx_vs_polygon_comparison" time="0.555" /><testcase classname="tests.backtest.test_index_data_verification.TestIndexDataVerification" name="test_vix_vs_polygon_comparison" time="0.504" /><testcase classname="tests.backtest.test_index_data_verification.TestIndexDataVerification" name="test_index_ohlc_consistency" time="0.476" /><testcase classname="tests.backtest.test_index_data_verification.TestIndexDataVerification" name="test_index_no_missing_bars" time="0.383" /><testcase classname="tests.backtest.test_multileg_backtest" name="test_multileg_spread_backtest_cash_and_parent_fill" time="5.983" /><testcase classname="tests.backtest.test_pandas_backtest.TestPandasBacktest" name="test_pandas_data_fixture" time="0.326" /><testcase classname="tests.backtest.test_pandas_backtest.TestPandasBacktest" name="test_pandas_datasource_with_daily_data_in_backtest" time="9.823" /><testcase classname="tests.backtest.test_pandas_backtest" name="test_bracket_orders_apply_entry_and_exit_fees" time="4.440" /><testcase classname="tests.backtest.test_passing_trader_into_backtest.TestPassingTraderIntoBacktest" name="test_not_passing_trader_class_into_backtest_creates_generic_trader" time="5.037" /><testcase classname="tests.backtest.test_passing_trader_into_backtest.TestPassingTraderIntoBacktest" name="test_passing_trader_class_into_backtest_creates_trader_class" time="7.634" /><testcase classname="tests.backtest.test_polygon.TestPolygonBacktestFull" name="test_polygon_restclient" time="5.052" /><testcase classname="tests.backtest.test_polygon.TestPolygonBacktestFull" name="test_intraday_daterange" time="4.694" /><testcase classname="tests.backtest.test_polygon.TestPolygonBacktestFull" name="test_polygon_legacy_backtest" time="5.540" /><testcase classname="tests.backtest.test_polygon.TestPolygonBacktestFull" name="test_polygon_legacy_backtest2" time="5.942" /><testcase classname="tests.backtest.test_polygon.TestPolygonBacktestFull" name="test_pull_source_symbol_bars_with_api_call" time="0.408" /><testcase classname="tests.backtest.test_polygon.TestPolygonDataSource" name="test_get_historical_prices" time="0.578" /><testcase classname="tests.backtest.test_polygon.TestPolygonDataSource" name="test_get_chains_spy_expected_data" time="0.417" /><testcase classname="tests.backtest.test_polygon.TestPolygonDataSource" name="test_get_last_price_unchanged" time="0.623" /><testcase classname="tests.backtest.test_polygon.TestPolygonDataSource" name="test_get_historical_prices_unchanged_for_amzn" time="0.569" /><testcase classname="tests.backtest.test_thetadata.TestThetaDataBacktestFull" name="test_thetadata_restclient" time="27.947" /><testcase classname="tests.backtest.test_thetadata.TestThetaDataBacktestFull" name="test_intraday_daterange" time="0.733" /><testcase classname="tests.backtest.test_thetadata.TestThetaDataSource" name="test_get_historical_prices" time="0.741" /><testcase classname="tests.backtest.test_thetadata.TestThetaDataSource" name="test_get_chains_spy_expected_data" time="153.122" /><testcase classname="tests.backtest.test_thetadata.TestThetaDataSource" name="test_get_last_price_unchanged" time="0.674" /><testcase classname="tests.backtest.test_thetadata.TestThetaDataSource" name="test_get_historical_prices_unchanged_for_amzn" time="0.674" /><testcase classname="tests.backtest.test_thetadata.TestThetaDataSource" name="test_pull_source_symbol_bars_with_api_call" time="0.521" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataStocks" name="test_first_10_minutes_timestamps_and_prices" time="0.533" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataStocks" name="test_noon_period_accuracy" time="0.722" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataStocks" name="test_multiple_symbols" time="1.120" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataMethods" name="test_get_quote" time="0.680" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataMethods" name="test_get_chains" time="86.550" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataOptions" name="test_atm_call_and_put" time="77.025" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataIndexes" name="test_spx_pricing" time="0.667" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataExtendedHours" name="test_premarket_data" time="0.768" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataQuoteContinuity" name="test_multi_day_option_quote_coverage" time="0.702" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataHelperLive" name="test_get_price_data_regular_vs_extended" time="3.730"><skipped type="pytest.skip" message="ThetaData did not return any extended-hours rows for SPY in this window">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/backtest/test_thetadata_comprehensive.py:556: ThetaData did not return any extended-hours rows for SPY in this window</skipped></testcase><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataHelperLive" name="test_get_price_data_multi_chunk_fetch" time="0.530" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataHelperLive" name="test_get_historical_data_option_live" time="0.828" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataHelperLive" name="test_get_historical_data_index_live" time="0.822" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataHelperLive" name="test_get_historical_data_quote_style" time="2.329" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataHelperLive" name="test_get_historical_data_no_data_returns_none" time="0.794" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataHelperLive" name="test_get_expirations_and_strikes_live" time="0.948" /><testcase classname="tests.backtest.test_thetadata_comprehensive.TestThetaDataPagination" name="test_pagination_with_mock" time="0.456" /><testcase classname="tests.backtest.test_thetadata_vs_polygon.TestThetaDataVsPolygonComparison" name="test_stock_price_comparison" time="8.335" /><testcase classname="tests.backtest.test_thetadata_vs_polygon.TestThetaDataVsPolygonComparison" name="test_option_price_comparison" time="37.557" /><testcase classname="tests.backtest.test_thetadata_vs_polygon.TestThetaDataVsPolygonComparison" name="test_index_price_comparison" time="16.883"><failure message="ValueError: Cannot connect to Theta Data!">self = &lt;tests.backtest.test_thetadata_vs_polygon.TestThetaDataVsPolygonComparison object at 0x11c44ce30&gt;

    def test_index_price_comparison(self):
        """
        Tests SPX index data accessibility and timestamp accuracy.
    
        NOTE: ThetaData VALUE Indices plan only supports 15-minute intervals.
        This test verifies:
        1. SPX data is accessible
        2. Timestamps are correct (15-min intervals)
        3. OHLC data is consistent
        4. No timestamp offset bugs (like the +1 minute bug we fixed for stocks)
        """
        username = os.environ.get("THETADATA_USERNAME")
        password = os.environ.get("THETADATA_PASSWORD")
    
        from lumibot.tools import thetadata_helper
    
        asset = Asset("SPX", asset_type="index")
    
        # ThetaData - 15 minute intervals (VALUE plan limitation)
&gt;       theta_df = thetadata_helper.get_historical_data(
            asset=asset,
            start_dt=datetime.datetime(2024, 8, 1, 9, 30),
            end_dt=datetime.datetime(2024, 8, 1, 12, 0),
            ivl=900000,  # 15 minutes (900,000 ms) - VALUE plan supports this
            username=username,
            password=password,
            datastyle='ohlc'
        )

tests/backtest/test_thetadata_vs_polygon.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

asset = SPX, start_dt = datetime.datetime(2024, 8, 1, 9, 30)
end_dt = datetime.datetime(2024, 8, 1, 12, 0), ivl = 900000
username = 'rob@lumiwealth.com', password = 'x@t&amp;0&lt;M%Z70!pp*M*86J'
datastyle = 'ohlc', include_after_hours = True

    def get_historical_data(asset: Asset, start_dt: datetime, end_dt: datetime, ivl: int, username: str, password: str, datastyle:str = "ohlc", include_after_hours: bool = True):
        """
        Get data from ThetaData
    
        Parameters
        ----------
        asset : Asset
            The asset we are getting data for
        start_dt : datetime
            The start date/time for the data we want
        end_dt : datetime
            The end date/time for the data we want
        ivl : int
            The interval for the data we want in milliseconds (eg. 60000 for 1 minute)
        username : str
            Your ThetaData username
        password : str
            Your ThetaData password
        datastyle : str
            The style of data to retrieve ("ohlc" or "quote")
        include_after_hours : bool
            Whether to include after-hours trading data (default True)
    
        Returns
        -------
        pd.DataFrame
            A DataFrame with the data for the asset
        """
    
        # Comvert start and end dates to strings
        start_date = start_dt.strftime("%Y%m%d")
        end_date = end_dt.strftime("%Y%m%d")
    
        # Create the url based on the asset type
        # Indexes require v2 API as of ThetaTerminal v1.8.6
        if asset.asset_type == "index":
            url = f"{BASE_URL}/v2/hist/{asset.asset_type}/{datastyle}"
        else:
            url = f"{BASE_URL}/hist/{asset.asset_type}/{datastyle}"
    
        if asset.asset_type == "option":
            # Convert the expiration date to a string
            expiration_str = asset.expiration.strftime("%Y%m%d")
    
            # Convert the strike price to an integer and multiply by 1000
            strike = int(asset.strike * 1000)
    
            querystring = {
                "root": asset.symbol,
                "start_date": start_date,
                "end_date": end_date,
                "ivl": ivl,
                "strike": strike,  # "140000",
                "exp": expiration_str,  # "20220930",
                "right": "C" if asset.right == "CALL" else "P",
                # include_after_hours=True means extended hours (rth=false)
                # include_after_hours=False means regular hours only (rth=true)
                "rth": "false" if include_after_hours else "true"
            }
        elif asset.asset_type == "index":
            # For indexes (SPX, VIX, etc.), don't use rth parameter
            # Indexes are calculated values, not traded securities
            querystring = {
                "root": asset.symbol,
                "start_date": start_date,
                "end_date": end_date,
                "ivl": ivl
            }
        else:
            # For stocks, respect include_after_hours parameter
            # rth=false means extended hours (pre-market + regular + after-hours)
            # rth=true means 9:30 AM - 4:00 PM ET (regular market hours only)
            querystring = {
                "root": asset.symbol,
                "start_date": start_date,
                "end_date": end_date,
                "ivl": ivl,
                "rth": "false" if include_after_hours else "true"
            }
    
        headers = {"Accept": "application/json"}
    
        # Send the request
    
&gt;       json_resp = get_request(url=url, headers=headers, querystring=querystring,
                                username=username, password=password)

lumibot/tools/thetadata_helper.py:600: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://127.0.0.1:25510/v2/hist/index/ohlc'
headers = {'Accept': 'application/json'}
querystring = {'end_date': '20240801', 'ivl': 900000, 'root': 'SPX', 'start_date': '20240801'}
username = 'rob@lumiwealth.com', password = 'x@t&amp;0&lt;M%Z70!pp*M*86J'

    def get_request(url: str, headers: dict, querystring: dict, username: str, password: str):
        all_responses = []
        next_page_url = None
        page_count = 0
    
        while True:
            counter = 0
            # Use next_page URL if available, otherwise use original URL with querystring
            request_url = next_page_url if next_page_url else url
            request_params = None if next_page_url else querystring
    
            while True:
                try:
                    response = requests.get(request_url, headers=headers, params=request_params)
                    # If status code is not 200, then we are not connected
                    if response.status_code != 200:
                        check_connection(username=username, password=password)
                    else:
                        json_resp = response.json()
    
                        # Check if json_resp has error_type inside of header
                        if "error_type" in json_resp["header"] and json_resp["header"]["error_type"] != "null":
                            # Handle "NO_DATA" error
                            if json_resp["header"]["error_type"] == "NO_DATA":
                                logger.warning(
                                    f"No data returned for querystring: {querystring}")
                                return None
                            else:
                                logger.error(
                                    f"Error getting data from Theta Data: {json_resp['header']['error_type']},\nquerystring: {querystring}")
                                check_connection(username=username, password=password)
                        else:
                            break
    
                except Exception as e:
                    check_connection(username=username, password=password)
    
                counter += 1
                if counter &gt; 1:
&gt;                   raise ValueError("Cannot connect to Theta Data!")
E                   ValueError: Cannot connect to Theta Data!

lumibot/tools/thetadata_helper.py:491: ValueError</failure></testcase><testcase classname="tests.backtest.test_thetadata_vs_polygon.TestThetaDataVsPolygonComparison" name="test_fill_price_comparison" time="10.363" /><testcase classname="tests.backtest.test_thetadata_vs_polygon.TestThetaDataVsPolygonComparison" name="test_portfolio_value_comparison" time="10.089" /><testcase classname="tests.backtest.test_thetadata_vs_polygon.TestThetaDataVsPolygonComparison" name="test_cash_comparison" time="13.052" /><testcase classname="tests.backtest.test_yahoo.TestYahooBacktestFull" name="test_yahoo_last_price" time="5.547"><failure message="assert 416.18 == 419.2">self = &lt;tests.backtest.test_yahoo.TestYahooBacktestFull object at 0x11c30b5c0&gt;

    def test_yahoo_last_price(self):
        """
        Test the YahooDataBacktesting class by running a backtest and checking that the strategy object is returned
        along with the correct results
        """
        # Parameters: True = Live Trading | False = Backtest
        # trade_live = False
        backtesting_start = datetime.datetime(2023, 11, 1)
        backtesting_end = datetime.datetime(2023, 11, 2)
    
        data_source = YahooDataBacktesting(
            datetime_start=backtesting_start,
            datetime_end=backtesting_end,
        )
    
        broker = BacktestingBroker(data_source=data_source)
    
        poly_strat_obj = YahooPriceTest(
            broker=broker,
            backtesting_start=backtesting_start,
            backtesting_end=backtesting_end,
        )
    
        trader = Trader(logfile="", backtest=True)
        trader.add_strategy(poly_strat_obj)
        results = trader.run_all(show_plot=False, show_tearsheet=False, show_indicators=False, save_tearsheet=False, tearsheet_file="")
    
        assert results
    
        last_price = poly_strat_obj.last_price
        # Round to 2 decimal places
        last_price = round(last_price, 2)
    
&gt;       assert last_price == 419.20  # This is the correct price for 2023-11-01 (the open price)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 416.18 == 419.2

tests/backtest/test_yahoo.py:64: AssertionError</failure></testcase><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_initialize_broker_legacy" time="1.674" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_submit_order_calls_conform_order" time="1.475" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_limit_order_conforms_when_limit_price_gte_one_dollar" time="0.596" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_limit_order_conforms_when_limit_price_lte_one_dollar" time="0.595" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_option_get_last_price" time="0.000"><skipped type="pytest.skip" message="This test is doesn't work.">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_alpaca.py:59: This test is doesn't work.</skipped></testcase><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_stock_get_last_price" time="1.730" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_crypto_get_last_price" time="1.285" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_get_historical_prices" time="1.558" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_option_get_historical_prices" time="2.256" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_oauth_broker_initialization" time="0.605" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_oauth_mixed_credentials" time="0.607" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_oauth_fallback_to_api_keys" time="0.611" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_oauth_error_on_missing_credentials" time="0.609" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_oauth_stream_object_creation" time="0.602" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_oauth_polling_interval" time="0.598" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_custom_params_extended_hours" time="0.602" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_custom_params_multiple_params" time="0.607" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_custom_params_none" time="0.608" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_parse_broker_order_with_none_quantity" time="0.609" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_parse_broker_order_with_valid_quantity" time="0.599" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_parse_broker_order_with_zero_quantity" time="0.606" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_parse_broker_order_with_avg_fill_price_and_date_created" time="0.565" /><testcase classname="tests.test_alpaca.TestAlpacaBroker" name="test_parse_broker_order_without_avg_fill_price_and_date_created" time="0.568" /><testcase classname="tests.test_alpaca_auth_fix.TestAlpacaAuthFix" name="test_auth_failed_flag_not_set_for_network_errors" time="0.599" /><testcase classname="tests.test_alpaca_auth_fix.TestAlpacaAuthFix" name="test_auth_failed_flag_set_for_real_auth_errors" time="0.568" /><testcase classname="tests.test_alpaca_auth_fix.TestAlpacaAuthFix" name="test_reset_auth_failure_method" time="0.569" /><testcase classname="tests.test_alpaca_auth_fix.TestAlpacaAuthFix" name="test_client_initialization_with_network_error" time="0.569" /><testcase classname="tests.test_alpaca_auth_fix.TestAlpacaAuthFix" name="test_client_initialization_with_auth_error" time="0.576" /><testcase classname="tests.test_alpaca_auth_fix.TestAlpacaAuthFix" name="test_get_chains_blocked_after_auth_failure" time="0.604" /><testcase classname="tests.test_alpaca_auth_fix.TestAlpacaAuthFix" name="test_different_auth_error_patterns" time="0.620" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_create_data_source" time="0.689" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_basic_key_generation_crypto" time="0.614" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_basic_key_generation_stock" time="0.696" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_with_auto_adjust" time="0.679" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_empty_market_false_auto_adjust" time="0.611" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_different_timezones" time="0.619" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_refresh_cache" time="1.218" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_no_refresh_cache" time="0.620" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_reindex_and_fill_day_when_all_data_exists" time="0.661" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_reindex_and_fill_day_when_missing_dates" time="0.574" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_reindex_and_fill_day_when_missing_dates_beginning" time="0.604" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_reindex_and_fill_minute_when_missing_dates" time="0.622" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_amzn_day_1d" time="0.746" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_amzn_day_1d_5" time="0.902" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_amzn_minute_1d" time="0.811" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_amzn_minute_1d_5" time="0.806" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_amzn_minute_30m_5" time="0.843" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_btc_day_1d_utc" time="0.764" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_btc_minute_1d" time="0.808" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_btc_minute_1d_5" time="0.844" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_btc_minute_30m_5" time="0.950" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_amzn_day_1d_dump_benchmark_stats" time="0.832" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_amzn_day_1d_benchmark_asset_loaded_when_benchmark_asset_not_in_strategy" time="0.832" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_amzn_day_1d_benchmark_asset_loaded_when_benchmark_asset_is_crypto" time="0.833" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_amzn_day_1m_dump_benchmark_stats" time="0.867" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_oauth_config_backtesting" time="0.760" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_oauth_mixed_config_backtesting" time="0.651" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktesting" name="test_oauth_fallback_backtesting" time="0.692" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktestingDataSource" name="test_get_last_price_daily_bars_stock" time="0.779" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktestingDataSource" name="test_get_last_price_daily_bars_crypto" time="0.692" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktestingDataSource" name="test_get_last_price_minute_bars_stock" time="0.740" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktestingDataSource" name="test_get_last_price_minute_bars_crypto" time="0.667" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktestingDataSource" name="test_get_historical_prices_minute_bars_stock" time="0.763" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktestingDataSource" name="test_get_historical_prices_minute_bars_stock_remove_incomplete_current_bar" time="0.676" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktestingDataSource" name="test_get_historical_prices_minute_bars_crypto" time="0.668" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktestingDataSource" name="test_get_historical_prices_daily_bars_stock" time="0.755" /><testcase classname="tests.test_alpaca_backtesting.TestAlpacaBacktestingDataSource" name="test_get_historical_prices_daily_bars_crypto" time="0.701" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_last_price_crypto" time="1.518" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_last_price_stock" time="1.636" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_historical_prices_daily_bars_stock" time="1.986" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_historical_prices_daily_bars_stock_remove_incomplete_current_bar" time="1.839" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_historical_prices_daily_bars_stock_tuple" time="1.731" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_historical_prices_daily_bars_stock_split_adjusted" time="0.711" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_historical_prices_daily_bars_crypto" time="1.283"><skipped type="pytest.xfail" message="need to handle github timezone" /></testcase><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_historical_prices_daily_bars_crypto_tuple" time="1.430"><skipped type="pytest.xfail" message="need to handle github timezone" /></testcase><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_historical_prices_daily_bars_crypto_utc" time="1.818" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_historical_prices_minute_bars_stock_regular_hours" time="2.058" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_historical_prices_minute_bars_crypto_utc" time="2.800" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_historical_option_prices" time="1.885" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_quote_stock" time="0.758" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_quote_crypto" time="1.336" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_quote_when_stock_bid_is_zero" time="0.690" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_quote_when_stock_ask_is_zero" time="0.687" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_last_price_stock_when_bid_is_zero" time="0.687" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_last_price_stock_when_ask_is_zero" time="0.691" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_last_price_stock_when_last" time="0.686" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_get_quote_when_stock_bid_and_ask" time="0.688" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_oauth_data_source_initialization" time="0.708" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_oauth_client_initialization" time="0.689" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_api_key_priority_over_oauth" time="0.699" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_oauth_empty_fallback_to_api_key" time="0.688" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_oauth_none_fallback_to_api_key" time="0.687" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_oauth_no_credentials_error" time="0.691" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_oauth_missing_api_secret_error" time="0.697" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_default_delay_value" time="0.692" /><testcase classname="tests.test_alpaca_data.TestAlpacaData" name="test_data_source_delay_env_var" time="0.693" /><testcase classname="tests.test_alpaca_helpers" name="test_sanitize_base_and_quote_asset" time="0.686" /><testcase classname="tests.test_alpaca_multileg_fix.TestAlpacaMultiLegOrders" name="test_multileg_order_class_is_correct" time="0.691" /><testcase classname="tests.test_alpaca_multileg_fix.TestAlpacaMultiLegOrders" name="test_multileg_order_has_required_fields" time="0.694" /><testcase classname="tests.test_alpaca_multileg_fix.TestAlpacaMultiLegOrders" name="test_side_mapping_for_multileg_orders" time="0.682" /><testcase classname="tests.test_alpaca_multileg_fix.TestAlpacaMultiLegOrders" name="test_multileg_order_with_limit_price" time="0.698" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_api_key_broker_initialization" time="0.687" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_api_key_client_creation" time="0.696" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_api_key_data_source_initialization" time="0.706" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_api_key_stream_object" time="0.699" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_mixed_credentials_broker" time="0.705" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_mixed_credentials_data_source" time="0.704" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_no_credentials_error" time="0.701" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_oauth_broker_initialization" time="0.711" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_oauth_client_creation" time="0.700" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_oauth_constants" time="0.699" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_oauth_data_source_initialization" time="0.702" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_oauth_error_handling_stops_execution" time="0.695" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_oauth_only_stream_object" time="0.694" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_oauth_polling_interval_custom" time="0.703" /><testcase classname="tests.test_alpaca_oauth.TestAlpacaOAuth" name="test_strategy_none_handling" time="0.712" /><testcase classname="tests.test_apscheduler_warnings" name="test_sleeptime_10s_max_instances" time="0.715" /><testcase classname="tests.test_apscheduler_warnings" name="test_sleeptime_1m_default_max_instances" time="0.715" /><testcase classname="tests.test_apscheduler_warnings" name="test_calculate_max_instances_for_sleeptime" time="0.672" /><testcase classname="tests.test_asset" name="test_check_default_asset_name" time="0.655" /><testcase classname="tests.test_asset" name="test_check_default_asset_type" time="0.662" /><testcase classname="tests.test_asset" name="test_check_defaults_with_stock" time="0.663" /><testcase classname="tests.test_asset" name="test_is_hashable" time="0.660" /><testcase classname="tests.test_asset" name="test_extra_attributes_at_initialization" time="0.658" /><testcase classname="tests.test_asset" name="test_instances_equal" time="0.656" /><testcase classname="tests.test_asset" name="test_symbol2asset" time="0.657" /><testcase classname="tests.test_asset" name="test_right_validator[not_call_or_CALL]" time="0.662" /><testcase classname="tests.test_asset" name="test_right_validator[not_put_or_PUT]" time="0.660" /><testcase classname="tests.test_asset" name="test_right_validator[CALLS]" time="0.661" /><testcase classname="tests.test_asset" name="test_right_validator[PUTS]" time="0.689" /><testcase classname="tests.test_asset" name="test_asset_types_validator[bonds]" time="0.675" /><testcase classname="tests.test_asset" name="test_asset_types_validator[cash]" time="0.659" /><testcase classname="tests.test_asset" name="test_asset_types_validator[swaptions]" time="0.686" /><testcase classname="tests.test_asset" name="test_continuous_futures_asset_creation" time="0.668" /><testcase classname="tests.test_asset" name="test_resolve_continuous_futures_contract" time="0.657" /><testcase classname="tests.test_asset" name="test_resolve_continuous_futures_contract_year_digits" time="0.659" /><testcase classname="tests.test_asset" name="test_resolve_continuous_futures_contract_rolls_mid_month" time="0.657" /><testcase classname="tests.test_asset" name="test_get_potential_futures_contracts" time="0.656" /><testcase classname="tests.test_asset" name="test_futures_contract_resolution_monthly_cycles" time="0.658" /><testcase classname="tests.test_asset" name="test_different_futures_symbols" time="0.657" /><testcase classname="tests.test_asset" name="test_continuous_futures_equality" time="0.659" /><testcase classname="tests.test_asset" name="test_continuous_futures_inequality" time="0.658" /><testcase classname="tests.test_asset" name="test_futures_contract_with_year_rollover" time="0.665" /><testcase classname="tests.test_asset" name="test_asset_type_enum_values" time="0.702" /><testcase classname="tests.test_asset" name="test_continuous_futures_string_representation" time="0.694" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_asset_creation_with_auto_expiry_front_month" time="0.698" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_asset_creation_with_auto_expiry_next_quarter" time="0.693" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_asset_creation_with_auto_expiry_true" time="0.700" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_asset_creation_with_auto_expiry_auto" time="0.700" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_manual_expiration_overrides_auto_expiry" time="0.699" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_auto_expiry_only_applies_to_futures" time="0.695" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_front_month_calculation_march" time="0.693" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_front_month_calculation_after_expiry" time="0.696" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_front_month_calculation_january" time="0.693" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_front_month_calculation_december" time="0.697" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_third_friday_calculation" time="0.694" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_invalid_auto_expiry_defaults_to_front_month" time="0.689" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_asset_with_datetime_expiration_conversion" time="0.686" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_asset_string_representation_with_auto_expiry" time="0.692" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_asset_equality_with_auto_expiry" time="0.687" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_next_quarter_same_as_front_month" time="0.707" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_continuous_futures_creation" time="0.694" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiry" name="test_continuous_futures_vs_auto_expiry" time="0.694" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiryIntegration" name="test_auto_expiry_with_symbol_parsing" time="0.696" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiryIntegration" name="test_auto_expiry_with_multiplier" time="0.689" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiryIntegration" name="test_auto_expiry_preserved_in_asset_attributes" time="0.691" /><testcase classname="tests.test_asset_auto_expiry.TestAssetAutoExpiryIntegration" name="test_asset_validation_with_auto_expiry" time="0.697" /><testcase classname="tests.test_auto_market_inference" name="test_projectx_sets_us_futures" time="0.704" /><testcase classname="tests.test_auto_market_inference" name="test_tradovate_sets_us_futures" time="0.659" /><testcase classname="tests.test_auto_market_inference" name="test_ccxt_sets_24_7" time="0.690" /><testcase classname="tests.test_auto_market_inference" name="test_no_change_if_configured" time="0.689" /><testcase classname="tests.test_backtesting_broker.TestBacktestingBroker" name="test_limit_fills" time="0.692" /><testcase classname="tests.test_backtesting_broker.TestBacktestingBroker" name="test_stop_fills" time="0.690" /><testcase classname="tests.test_backtesting_broker.TestBacktestingBroker" name="test_submit_order_calls_conform_order" time="0.666" /><testcase classname="tests.test_backtesting_broker.TestBacktestingBrokerTimeAdvance" name="test_await_close_during_market_hours_no_buffer" time="0.651" /><testcase classname="tests.test_backtesting_broker.TestBacktestingBrokerTimeAdvance" name="test_await_close_get_time_to_close_returns_none" time="0.649" /><testcase classname="tests.test_backtesting_broker.TestBacktestingBrokerTimeAdvance" name="test_await_close_when_already_past_close_no_buffer" time="0.678" /><testcase classname="tests.test_backtesting_broker.TestBacktestingBrokerTimeAdvance" name="test_await_close_with_buffer" time="0.692" /><testcase classname="tests.test_backtesting_broker.TestBacktestingBrokerTimeAdvance" name="test_await_open_before_market_opens_no_buffer" time="0.674" /><testcase classname="tests.test_backtesting_broker.TestBacktestingBrokerTimeAdvance" name="test_await_open_when_market_already_open" time="0.650" /><testcase classname="tests.test_backtesting_broker.TestBacktestingBrokerTimeAdvance" name="test_await_open_with_buffer" time="0.651" /><testcase classname="tests.test_backtesting_broker.TestBacktestingBrokerTimeAdvance" name="test_await_open_with_buffer_making_time_negative" time="0.677" /><testcase classname="tests.test_backtesting_broker_await_close.TestBacktestingBrokerAwaitClose" name="test_await_close_during_market_hours_no_buffer" time="0.667" /><testcase classname="tests.test_backtesting_broker_await_close.TestBacktestingBrokerAwaitClose" name="test_await_close_get_time_to_close_returns_none" time="0.650" /><testcase classname="tests.test_backtesting_broker_await_close.TestBacktestingBrokerAwaitClose" name="test_await_close_when_already_past_close_no_buffer" time="0.657" /><testcase classname="tests.test_backtesting_broker_await_close.TestBacktestingBrokerAwaitClose" name="test_await_close_with_buffer" time="0.683" /><testcase classname="tests.test_backtesting_broker_await_close.TestBacktestingBrokerAwaitClose" name="test_await_close_with_buffer_making_time_negative" time="0.690" /><testcase classname="tests.test_backtesting_broker_time_advance.TestBacktestingBrokerTimeAdvance" name="test_await_close_during_market_hours_no_buffer" time="0.684" /><testcase classname="tests.test_backtesting_broker_time_advance.TestBacktestingBrokerTimeAdvance" name="test_await_close_get_time_to_close_returns_none" time="0.690" /><testcase classname="tests.test_backtesting_broker_time_advance.TestBacktestingBrokerTimeAdvance" name="test_await_close_when_already_past_close_no_buffer" time="0.666" /><testcase classname="tests.test_backtesting_broker_time_advance.TestBacktestingBrokerTimeAdvance" name="test_await_close_with_buffer" time="0.664" /><testcase classname="tests.test_backtesting_crypto_cash_unit" name="test_crypto_forex_buy_updates_cash_once" time="0.713" /><testcase classname="tests.test_backtesting_crypto_cash_unit" name="test_crypto_forex_round_trip_restores_cash_on_sell" time="0.710" /><testcase classname="tests.test_backtesting_crypto_cash_unit" name="test_crypto_crypto_pair_uses_quote_position_not_cash" time="0.702" /><testcase classname="tests.test_backtesting_crypto_cash_unit" name="test_filled_order_payload_contains_quantity_and_trade_cost" time="0.668" /><testcase classname="tests.test_backtesting_crypto_cash_unit" name="test_percent_fee_applied_once_to_cash_and_order" time="0.702" /><testcase classname="tests.test_backtesting_crypto_cash_unit" name="test_multiple_orders_same_cycle_keep_cash_consistent" time="0.674" /><testcase classname="tests.test_backtesting_crypto_cash_unit" name="test_option_round_trip_applies_multiplier" time="0.669" /><testcase classname="tests.test_backtesting_data_source_env.TestBacktestingDataSourceEnv" name="test_auto_select_polygon_case_insensitive" time="6.911"><failure message="AssertionError: Expected 'PolygonDataBacktesting' to have been called once. Called 0 times.&#10;Calls: [call.__eq__(&lt;class 'lumibot.backtesting.polygon_backtesting.PolygonDataBacktesting'&gt;)].">self = &lt;MagicMock name='PolygonDataBacktesting' id='4758089904'&gt;

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
&gt;           raise AssertionError(msg)
E           AssertionError: Expected 'PolygonDataBacktesting' to have been called once. Called 0 times.
E           Calls: [call.__eq__(&lt;class 'lumibot.backtesting.polygon_backtesting.PolygonDataBacktesting'&gt;)].

/opt/homebrew/Cellar/python@3.12/3.12.10/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;tests.test_backtesting_data_source_env.TestBacktestingDataSourceEnv object at 0x11c542570&gt;

    def test_auto_select_polygon_case_insensitive(self):
        """Test that BACKTESTING_DATA_SOURCE=polygon (lowercase) selects PolygonDataBacktesting."""
        with patch.dict(os.environ, {'BACKTESTING_DATA_SOURCE': 'polygon'}):
            # Re-import credentials to pick up env change
            from importlib import reload
            import lumibot.credentials
            reload(lumibot.credentials)
    
            # Mock the datasource to avoid actual data fetching
            with patch('lumibot.strategies._strategy.PolygonDataBacktesting') as MockPoly:
                mock_data_source = MagicMock()
                MockPoly.return_value = mock_data_source
    
                backtesting_start = datetime(2023, 1, 1)
                backtesting_end = datetime(2023, 1, 31)
    
                try:
                    SimpleTestStrategy.run_backtest(
                        None,  # Auto-select from env var
                        backtesting_start=backtesting_start,
                        backtesting_end=backtesting_end,
                        polygon_api_key="test_key",
                        show_plot=False,
                        show_tearsheet=False,
                        show_indicators=False,
                    )
                except:
                    pass  # We expect it to fail, we just want to verify the datasource was selected
    
                # Verify PolygonDataBacktesting was instantiated
&gt;               MockPoly.assert_called_once()
E               AssertionError: Expected 'PolygonDataBacktesting' to have been called once. Called 0 times.
E               Calls: [call.__eq__(&lt;class 'lumibot.backtesting.polygon_backtesting.PolygonDataBacktesting'&gt;)].

tests/test_backtesting_data_source_env.py:69: AssertionError</failure></testcase><testcase classname="tests.test_backtesting_data_source_env.TestBacktestingDataSourceEnv" name="test_auto_select_thetadata_case_insensitive" time="26.797"><failure message="AssertionError: Expected 'ThetaDataBacktesting' to have been called once. Called 0 times.">self = &lt;MagicMock name='ThetaDataBacktesting' id='16195554528'&gt;

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
&gt;           raise AssertionError(msg)
E           AssertionError: Expected 'ThetaDataBacktesting' to have been called once. Called 0 times.

/opt/homebrew/Cellar/python@3.12/3.12.10/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;tests.test_backtesting_data_source_env.TestBacktestingDataSourceEnv object at 0x11c542720&gt;

    def test_auto_select_thetadata_case_insensitive(self):
        """Test that BACKTESTING_DATA_SOURCE=THETADATA (uppercase) selects ThetaDataBacktesting."""
        with patch.dict(os.environ, {'BACKTESTING_DATA_SOURCE': 'THETADATA'}):
            # Re-import credentials to pick up env change
            from importlib import reload
            import lumibot.credentials
            reload(lumibot.credentials)
    
            # Mock the datasource to avoid actual data fetching
            with patch('lumibot.strategies._strategy.ThetaDataBacktesting') as MockTheta:
                mock_data_source = MagicMock()
                MockTheta.return_value = mock_data_source
    
                backtesting_start = datetime(2023, 1, 1)
                backtesting_end = datetime(2023, 1, 31)
    
                try:
                    SimpleTestStrategy.run_backtest(
                        None,  # Auto-select from env var
                        backtesting_start=backtesting_start,
                        backtesting_end=backtesting_end,
                        thetadata_username="test_user",
                        thetadata_password="test_pass",
                        show_plot=False,
                        show_tearsheet=False,
                        show_indicators=False,
                    )
                except:
                    pass  # We expect it to fail, we just want to verify the datasource was selected
    
                # Verify ThetaDataBacktesting was instantiated
&gt;               MockTheta.assert_called_once()
E               AssertionError: Expected 'ThetaDataBacktesting' to have been called once. Called 0 times.

tests/test_backtesting_data_source_env.py:102: AssertionError</failure></testcase><testcase classname="tests.test_backtesting_data_source_env.TestBacktestingDataSourceEnv" name="test_auto_select_yahoo" time="0.681"><failure message="AttributeError: &lt;module 'lumibot.strategies._strategy' from '/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/lumibot/strategies/_strategy.py'&gt; does not have the attribute 'YahooDataBacktesting'">self = &lt;tests.test_backtesting_data_source_env.TestBacktestingDataSourceEnv object at 0x11c542c90&gt;

    def test_auto_select_yahoo(self):
        """Test that BACKTESTING_DATA_SOURCE=Yahoo selects YahooDataBacktesting."""
        with patch.dict(os.environ, {'BACKTESTING_DATA_SOURCE': 'Yahoo'}):
            # Re-import credentials to pick up env change
            from importlib import reload
            import lumibot.credentials
            reload(lumibot.credentials)
    
            # Mock the datasource to avoid actual data fetching
&gt;           with patch('lumibot.strategies._strategy.YahooDataBacktesting') as MockYahoo:
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_backtesting_data_source_env.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x108c11b80&gt;

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
&gt;       original, local = self.get_original()
                          ^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.12/3.12.10/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x108c11b80&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'lumibot.strategies._strategy' from '/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/lumibot/strategies/_strategy.py'&gt; does not have the attribute 'YahooDataBacktesting'

/opt/homebrew/Cellar/python@3.12/3.12.10/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1437: AttributeError</failure></testcase><testcase classname="tests.test_backtesting_data_source_env.TestBacktestingDataSourceEnv" name="test_invalid_data_source_raises_error" time="0.781" /><testcase classname="tests.test_backtesting_data_source_env.TestBacktestingDataSourceEnv" name="test_explicit_datasource_overrides_env" time="0.785"><failure message="AttributeError: &lt;module 'lumibot.strategies._strategy' from '/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/lumibot/strategies/_strategy.py'&gt; does not have the attribute 'YahooDataBacktesting'">self = &lt;tests.test_backtesting_data_source_env.TestBacktestingDataSourceEnv object at 0x11c542e70&gt;

    def test_explicit_datasource_overrides_env(self):
        """Test that explicit datasource_class overrides BACKTESTING_DATA_SOURCE env var."""
        with patch.dict(os.environ, {'BACKTESTING_DATA_SOURCE': 'polygon'}):
            # Re-import credentials to pick up env change
            from importlib import reload
            import lumibot.credentials
            reload(lumibot.credentials)
    
            # Mock YahooDataBacktesting to verify it's used despite env var saying polygon
&gt;           with patch('lumibot.strategies._strategy.YahooDataBacktesting') as MockYahoo:
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_backtesting_data_source_env.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x3c54f89e0&gt;

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
&gt;       original, local = self.get_original()
                          ^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.12/3.12.10/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x3c54f89e0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'lumibot.strategies._strategy' from '/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/lumibot/strategies/_strategy.py'&gt; does not have the attribute 'YahooDataBacktesting'

/opt/homebrew/Cellar/python@3.12/3.12.10/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1437: AttributeError</failure></testcase><testcase classname="tests.test_backtesting_data_source_env.TestBacktestingDataSourceEnv" name="test_default_thetadata_when_no_env_set" time="17.109"><failure message="AssertionError: Expected 'ThetaDataBacktesting' to have been called once. Called 0 times.">self = &lt;MagicMock name='ThetaDataBacktesting' id='15574217936'&gt;

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
&gt;           raise AssertionError(msg)
E           AssertionError: Expected 'ThetaDataBacktesting' to have been called once. Called 0 times.

/opt/homebrew/Cellar/python@3.12/3.12.10/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;tests.test_backtesting_data_source_env.TestBacktestingDataSourceEnv object at 0x11c543080&gt;

    def test_default_thetadata_when_no_env_set(self):
        """Test that ThetaData is the default when BACKTESTING_DATA_SOURCE is not set."""
        # Remove BACKTESTING_DATA_SOURCE from env
        env_without_datasource = {k: v for k, v in os.environ.items() if k != 'BACKTESTING_DATA_SOURCE'}
    
        with patch.dict(os.environ, env_without_datasource, clear=True):
            # Re-import credentials to pick up env change
            from importlib import reload
            import lumibot.credentials
            reload(lumibot.credentials)
    
            # Mock the datasource to avoid actual data fetching
            with patch('lumibot.strategies._strategy.ThetaDataBacktesting') as MockTheta:
                mock_data_source = MagicMock()
                MockTheta.return_value = mock_data_source
    
                backtesting_start = datetime(2023, 1, 1)
                backtesting_end = datetime(2023, 1, 31)
    
                try:
                    SimpleTestStrategy.run_backtest(
                        None,  # Auto-select from env var (should default to ThetaData)
                        backtesting_start=backtesting_start,
                        backtesting_end=backtesting_end,
                        thetadata_username="test_user",
                        thetadata_password="test_pass",
                        show_plot=False,
                        show_tearsheet=False,
                        show_indicators=False,
                    )
                except:
                    pass
    
                # Verify ThetaDataBacktesting was instantiated (default)
&gt;               MockTheta.assert_called_once()
E               AssertionError: Expected 'ThetaDataBacktesting' to have been called once. Called 0 times.

tests/test_backtesting_data_source_env.py:221: AssertionError</failure></testcase><testcase classname="tests.test_backtesting_flow_control.TestBacktestingFlowControl" name="test_handles_complex_order_updates" time="0.709" /><testcase classname="tests.test_backtesting_flow_control.TestBacktestingFlowControl" name="test_handles_data_gaps" time="0.688" /><testcase classname="tests.test_backtesting_flow_control.TestBacktestingFlowControl" name="test_handles_strategy_exception" time="0.685" /><testcase classname="tests.test_backtesting_multileg_unit" name="test_multileg_parent_fills_after_all_children_complete" time="0.714" /><testcase classname="tests.test_backtesting_multileg_unit" name="test_multileg_parent_waits_if_any_child_pending" time="0.733" /><testcase classname="tests.test_backtesting_multileg_unit" name="test_multileg_child_fills_adjust_cash_once_and_parent_is_cash_neutral" time="0.725" /><testcase classname="tests.test_backtesting_quiet_logs_complete" name="test_default_backtesting_quiet_logs_is_true" time="0.686" /><testcase classname="tests.test_backtesting_quiet_logs_complete" name="test_quiet_logs_true_console_only_shows_progress_bar_and_errors" time="0.685" /><testcase classname="tests.test_backtesting_quiet_logs_complete" name="test_quiet_logs_true_file_only_shows_errors" time="0.708" /><testcase classname="tests.test_backtesting_quiet_logs_complete" name="test_quiet_logs_false_shows_all_info_plus" time="0.718" /><testcase classname="tests.test_backtesting_quiet_logs_complete" name="test_live_trading_always_shows_console_messages" time="0.685" /><testcase classname="tests.test_backtesting_quiet_logs_complete" name="test_progress_bar_always_shows_regardless_of_quiet_logs" time="0.696" /><testcase classname="tests.test_backtesting_quiet_logs_complete" name="test_bot_manager_compatibility" time="0.689" /><testcase classname="tests.test_backtesting_quiet_logs_complete" name="test_environment_variable_vs_function_parameter" time="1.216" /><testcase classname="tests.test_backtesting_quiet_logs_complete" name="test_error_level_equivalence" time="0.688" /><testcase classname="tests.test_bars_aggregate_frequency_normalization" name="test_aggregate_accepts_lowercase_minute_variants" time="0.698" /><testcase classname="tests.test_bars_aggregate_frequency_normalization" name="test_aggregate_rejects_unsupported_frequency" time="0.686" /><testcase classname="tests.test_bars_aggregation_timeunits" name="test_aggregate_bars_epoch_int_timestamp_minutes_failure_current" time="0.707" /><testcase classname="tests.test_bars_aggregation_timeunits" name="test_aggregate_bars_alias_variants_minutes" time="0.718" /><testcase classname="tests.test_bars_frequency_flex" name="test_arbitrary_minute_frequency" time="0.690" /><testcase classname="tests.test_bars_frequency_flex" name="test_hour_and_second_frequencies" time="0.737" /><testcase classname="tests.test_bars_frequency_flex" name="test_invalid_frequency_raises" time="0.681" /><testcase classname="tests.test_bars_frequency_flex" name="test_bars_datetime_index_normalized_to_default_timezone" time="0.721" /><testcase classname="tests.test_botspot_handler" name="test_botspot_handler_dedup_and_aggregation" time="1.816" /><testcase classname="tests.test_botspot_handler" name="test_botspot_handler_distinct_fingerprints" time="0.701" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_handler_initialization_without_api_key" time="0.724" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_handler_initialization_with_api_key" time="0.717" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_log_level_to_severity_mapping" time="0.734" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_extract_error_info_basic" time="0.726" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_extract_error_info_with_strategy" time="0.721" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_extract_error_info_structured_format" time="0.722" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_extract_error_info_strategy_with_structured_format" time="0.724" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_extract_error_info_strategy_name_in_message" time="0.687" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_extract_error_info_no_double_spacing" time="0.682" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_report_to_botspot_success" time="0.722" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_emit_without_api_key" time="0.722" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_emit_below_warning_level" time="0.714" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_duplicate_aggregation" time="1.789" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_rate_limit_window" time="2.819" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_max_errors_per_minute" time="0.719" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_rate_limit_counter_reset" time="0.705" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_api_error_uses_logging_not_print" time="0.678" /><testcase classname="tests.test_botspot_logger.TestBotspotErrorHandler" name="test_api_exception_uses_logging_not_print" time="0.714" /><testcase classname="tests.test_botspot_logger.TestBotspotIntegration" name="test_handler_not_added_without_api_key" time="0.684" /><testcase classname="tests.test_botspot_logger.TestBotspotIntegration" name="test_strategy_logger_integration" time="0.682" /><testcase classname="tests.test_broker_bitunix.TestBitunixBroker" name="test_get_balances_at_broker" time="0.682" /><testcase classname="tests.test_broker_bitunix.TestBitunixBroker" name="test_initialization_missing_keys" time="0.685" /><testcase classname="tests.test_broker_bitunix.TestBitunixBroker" name="test_initialization_success" time="0.694" /><testcase classname="tests.test_broker_bitunix.TestBitunixBroker" name="test_map_status_from_bitunix" time="1.552" /><testcase classname="tests.test_broker_bitunix.TestBitunixBroker" name="test_parse_broker_order" time="0.685" /><testcase classname="tests.test_broker_bitunix.TestBitunixBroker" name="test_parse_source_timestep" time="1.663" /><testcase classname="tests.test_broker_bitunix.TestBitunixBroker" name="test_pull_positions_success" time="0.698" /><testcase classname="tests.test_broker_cleanup.TestBrokerCleanup" name="test_cleanup_age_based_retention" time="0.684" /><testcase classname="tests.test_broker_cleanup.TestBrokerCleanup" name="test_cleanup_count_based_retention" time="0.685" /><testcase classname="tests.test_broker_cleanup.TestBrokerCleanup" name="test_cleanup_disabled" time="0.683" /><testcase classname="tests.test_broker_cleanup.TestBrokerCleanup" name="test_cleanup_preserves_recent_items" time="0.683" /><testcase classname="tests.test_broker_cleanup.TestBrokerCleanup" name="test_cleanup_respects_min_keep" time="0.688" /><testcase classname="tests.test_broker_cleanup.TestBrokerCleanup" name="test_cleanup_thread_safety" time="0.753" /><testcase classname="tests.test_broker_cleanup.TestBrokerCleanup" name="test_cleanup_with_missing_timestamps" time="0.683" /><testcase classname="tests.test_broker_cleanup.TestBrokerCleanup" name="test_custom_cleanup_config_initialization" time="0.688" /><testcase classname="tests.test_broker_cleanup.TestBrokerCleanup" name="test_default_cleanup_config_initialization" time="0.685" /><testcase classname="tests.test_broker_cleanup.TestBrokerCleanup" name="test_full_cleanup_process" time="0.685" /><testcase classname="tests.test_broker_cleanup.TestBrokerCleanup" name="test_manual_force_cleanup" time="0.684" /><testcase classname="tests.test_broker_cleanup.TestBrokerCleanup" name="test_periodic_cleanup_trigger" time="0.686" /><testcase classname="tests.test_broker_initialization.TestBrokerInitializationSimple" name="test_strategy_with_none_broker_raises_helpful_error" time="1.302" /><testcase classname="tests.test_broker_initialization.TestBrokerInitializationSimple" name="test_strategy_with_valid_broker_does_not_raise_broker_error" time="0.685" /><testcase classname="tests.test_brokers_handle_crypto.TestBrokerHandlesCrypto" name="test_yahoo_backtesting_with_symbol" time="0.690" /><testcase classname="tests.test_brokers_handle_crypto.TestBrokerHandlesCrypto" name="test_polygon_backtesting_with_base_and_quote" time="0.759" /><testcase classname="tests.test_brokers_handle_crypto.TestBrokerHandlesCrypto" name="test_alpaca_broker_with_base_and_quote" time="2.228"><skipped type="pytest.xfail" message="need to handle github timezone" /></testcase><testcase classname="tests.test_brokers_handle_crypto.TestBrokerHandlesCrypto" name="test_ccxt_backtesting_with_base_and_quote" time="0.000"><skipped type="pytest.skip" message="CCXT integration test requires stable network connection and external API availability">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_brokers_handle_crypto.py:160: CCXT integration test requires stable network connection and external API availability</skipped></testcase><testcase classname="tests.test_cash.TestCash" name="test_backtest_setup_cash_handling" time="0.690" /><testcase classname="tests.test_cash.TestCash" name="test_cash_after_position_creation" time="0.694" /><testcase classname="tests.test_cash.TestCash" name="test_cash_after_trade_simulation" time="0.690" /><testcase classname="tests.test_cash.TestCash" name="test_cash_consistency_during_backtest_lifecycle" time="0.689" /><testcase classname="tests.test_cash.TestCash" name="test_cash_division_operation" time="0.689" /><testcase classname="tests.test_cash.TestCash" name="test_cash_multiple_position_updates" time="0.693" /><testcase classname="tests.test_cash.TestCash" name="test_cash_property_and_method_consistency" time="0.688" /><testcase classname="tests.test_cash.TestCash" name="test_cash_property_never_none" time="0.699" /><testcase classname="tests.test_cash.TestCash" name="test_cash_with_decimal_values" time="0.728" /><testcase classname="tests.test_cash.TestCash" name="test_cash_with_property_and_method_interleaved" time="0.691" /><testcase classname="tests.test_cash.TestCash" name="test_cash_with_zero_value" time="0.690" /><testcase classname="tests.test_cash.TestCash" name="test_division_with_different_prices" time="0.690" /><testcase classname="tests.test_cash.TestCash" name="test_get_cash_method_never_none" time="0.694" /><testcase classname="tests.test_cash.TestCash" name="test_initial_cash_equals_budget" time="0.701" /><testcase classname="tests.test_cash.TestCash" name="test_multiple_get_cash_calls" time="0.718" /><testcase classname="tests.test_cash.TestCash" name="test_no_private_cash_variable" time="0.703" /><testcase classname="tests.test_cash.TestCash" name="test_strategy_mathematical_operations" time="0.702" /><testcase classname="tests.test_cash.TestCashWithDifferentBudgets" name="test_various_budget_amounts" time="0.694" /><testcase classname="tests.test_ccxt" name="test_initialize_ccxt_broker_legacy" time="3.955" /><testcase classname="tests.test_ccxt_store" name="test_cache_download_data[bitmex-ETH/USDT-1d-start0-end0]" time="0.000"><skipped type="pytest.skip" message="CCXT integration test requires stable network connection and external API availability">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_ccxt_store.py:10: CCXT integration test requires stable network connection and external API availability</skipped></testcase><testcase classname="tests.test_ccxt_store" name="test_cache_download_data_without_overap[bitmex-ETH/USDT-1d-start0-end0]" time="0.000"><skipped type="pytest.skip" message="CCXT integration test requires stable network connection and external API availability">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_ccxt_store.py:52: CCXT integration test requires stable network connection and external API availability</skipped></testcase><testcase classname="tests.test_configs_helper.TestConfigsHelper" name="test_get_classic_60_40_config" time="0.710" /><testcase classname="tests.test_continuous_futures.TestFuturesSymbolsUtilities" name="test_parse_contract_symbol_tradovate_style" time="0.702" /><testcase classname="tests.test_continuous_futures.TestFuturesSymbolsUtilities" name="test_parse_contract_symbol_standard_style" time="0.698" /><testcase classname="tests.test_continuous_futures.TestFuturesSymbolsUtilities" name="test_parse_contract_symbol_dot_notation" time="0.696" /><testcase classname="tests.test_continuous_futures.TestFuturesSymbolsUtilities" name="test_parse_contract_symbol_full_year" time="0.699" /><testcase classname="tests.test_continuous_futures.TestFuturesSymbolsUtilities" name="test_parse_contract_symbol_invalid" time="0.709" /><testcase classname="tests.test_continuous_futures.TestFuturesSymbolsUtilities" name="test_symbol_matches_root" time="0.713" /><testcase classname="tests.test_continuous_futures.TestFuturesSymbolsUtilities" name="test_from_ib_expiration_to_code" time="0.695" /><testcase classname="tests.test_continuous_futures.TestFuturesSymbolsUtilities" name="test_generate_symbol_variants" time="0.698" /><testcase classname="tests.test_continuous_futures.TestFuturesSymbolsUtilities" name="test_get_contract_priority_key" time="0.696" /><testcase classname="tests.test_continuous_futures.TestFuturesSymbolsUtilities" name="test_build_ib_contract_variants" time="0.699" /><testcase classname="tests.test_continuous_futures.TestAssetPotentialContracts" name="test_includes_single_digit_variants" time="0.695" /><testcase classname="tests.test_continuous_futures.TestAssetPotentialContracts" name="test_preserves_existing_order" time="0.695" /><testcase classname="tests.test_continuous_futures.TestAssetPotentialContracts" name="test_quarterly_contracts_prioritized" time="0.707" /><testcase classname="tests.test_continuous_futures.TestContinuousFuturesPositionMatching" name="test_non_continuous_future_unchanged" time="0.697" /><testcase classname="tests.test_continuous_futures.TestContinuousFuturesPositionMatching" name="test_continuous_future_exact_match" time="0.697" /><testcase classname="tests.test_continuous_futures.TestContinuousFuturesPositionMatching" name="test_continuous_future_single_contract_match" time="0.698" /><testcase classname="tests.test_continuous_futures.TestContinuousFuturesPositionMatching" name="test_continuous_future_multiple_contracts_priority" time="0.699" /><testcase classname="tests.test_continuous_futures.TestContinuousFuturesPositionMatching" name="test_continuous_future_ib_style_positions" time="0.698" /><testcase classname="tests.test_continuous_futures.TestContinuousFuturesPositionMatching" name="test_continuous_future_no_matches" time="0.697" /><testcase classname="tests.test_continuous_futures.TestContinuousFuturesPositionMatching" name="test_continuous_future_ignores_non_futures" time="0.698" /><testcase classname="tests.test_continuous_futures.TestContinuousFuturesPositionMatching" name="test_continuous_future_empty_positions" time="0.701" /><testcase classname="tests.test_continuous_futures_integration.TestContinuousFuturesIntegration" name="test_asset_class_consistency" time="0.696" /><testcase classname="tests.test_continuous_futures_integration.TestContinuousFuturesIntegration" name="test_centralization_verification" time="0.703" /><testcase classname="tests.test_continuous_futures_integration.TestContinuousFuturesIntegration" name="test_contract_format_standardization" time="0.698" /><testcase classname="tests.test_continuous_futures_integration.TestContinuousFuturesIntegration" name="test_databento_integration_consistency" time="0.698" /><testcase classname="tests.test_continuous_futures_integration.TestContinuousFuturesIntegration" name="test_error_handling_consistency" time="0.717" /><testcase classname="tests.test_continuous_futures_integration.TestContinuousFuturesIntegration" name="test_multi_component_consistency" time="0.737" /><testcase classname="tests.test_continuous_futures_integration.TestContinuousFuturesIntegration" name="test_no_duplicate_logic_verification" time="0.733" /><testcase classname="tests.test_continuous_futures_integration.TestContinuousFuturesIntegration" name="test_quarterly_preference_consistency" time="0.715" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_contract_format_validation" time="0.732" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_contract_ordering_priority" time="0.697" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_different_symbol_formats" time="0.739" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_error_handling_non_continuous_futures" time="0.702" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_expiration_edge_cases" time="0.689" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_format_continuous_futures_symbol" time="0.699" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_format_specific_futures_symbol" time="0.724" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_generate_current_futures_contract_july" time="0.729" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_generate_potential_contracts_july" time="0.731" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_integration_with_databento_helper" time="0.723" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_month_code_mapping" time="0.723" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_month_progression_logic" time="0.731" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_potential_contracts_uniqueness" time="0.693" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_quarterly_contract_consistency" time="0.683" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_quarterly_contract_preference" time="0.684" /><testcase classname="tests.test_continuous_futures_resolution.TestContinuousFuturesResolution" name="test_year_rollover_edge_cases" time="0.687" /><testcase classname="tests.test_data_source.TestDataSource" name="test_get_chain_full_info" time="0.691" /><testcase classname="tests.test_databento_asset_validation.TestDataBentoAssetValidation" name="test_live_data_source_futures_allowed" time="9.800" /><testcase classname="tests.test_databento_asset_validation.TestDataBentoAssetValidation" name="test_live_data_source_equities_rejected" time="2.622" /><testcase classname="tests.test_databento_asset_validation.TestDataBentoAssetValidation" name="test_helper_function_allows_all_assets" time="35.752" /><testcase classname="tests.test_databento_asset_validation.TestDataBentoAssetValidation" name="test_backtesting_allows_all_assets" time="0.739" /><testcase classname="tests.test_databento_asset_validation.TestDataBentoAssetValidation" name="test_benchmark_asset_in_backtesting_only" time="0.740" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoAutoExpiryIntegration" name="test_databento_symbol_formatting_with_auto_expiry" time="0.744" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoAutoExpiryIntegration" name="test_databento_symbol_with_different_auto_expiry_types" time="0.751" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoAutoExpiryIntegration" name="test_databento_symbol_consistency_across_dates" time="0.760" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoAutoExpiryIntegration" name="test_databento_symbol_with_manual_vs_auto_expiry" time="0.761" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoAutoExpiryIntegration" name="test_databento_symbol_handles_stock_asset" time="0.782" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoAutoExpiryIntegration" name="test_databento_symbol_changes_with_date" time="0.754" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoAutoExpiryIntegration" name="test_multiple_futures_with_auto_expiry" time="0.718" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoBacktestingAutoExpiry" name="test_asset_auto_expiry_in_strategy_context" time="0.714" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoBacktestingAutoExpiry" name="test_asset_auto_expiry_serialization" time="0.708" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoBacktestingAutoExpiry" name="test_asset_expiry_stability_during_backtest" time="0.740" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoBacktestingAutoExpiry" name="test_asset_auto_expiry_edge_cases" time="0.719" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoBacktestingAutoExpiry" name="test_asset_auto_expiry_with_existing_strategy_pattern" time="0.717" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoHelperMethods" name="test_format_symbol_with_quarterly_expiry" time="0.715" /><testcase classname="tests.test_databento_auto_expiry_integration.TestDataBentoHelperMethods" name="test_format_symbol_consistency" time="0.723" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_get_bars_dict_no_data" time="0.714" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_get_bars_dict_success" time="0.709" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_get_bars_dict_with_timeshift" time="0.712" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_get_chains" time="0.709" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_get_last_price_from_cached_data" time="0.706" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_get_last_price_no_cached_data" time="0.709" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_initialization_databento_unavailable" time="1.598" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_initialization_success" time="0.704" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_prefetch_data_multiple_assets" time="0.707" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_prefetch_data_single_asset" time="0.704" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_prefetch_handles_no_data" time="3.130" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_prefetch_skips_duplicate_requests" time="0.711" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_update_pandas_data_existing_sufficient_data" time="2.615" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_update_pandas_data_no_data" time="2.845" /><testcase classname="tests.test_databento_backtesting.TestDataBentoDataBacktesting" name="test_update_pandas_data_success" time="0.720" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_backtesting_mode_detection" time="0.723" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_environment_dates_integration" time="0.768" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_error_handling" time="2.019" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_get_chains" time="0.761" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_get_historical_prices_backtesting_path" time="0.772" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_get_historical_prices_error_handling" time="1.352" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_get_historical_prices_no_data" time="4.938" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_get_historical_prices_single_asset" time="0.779" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_get_historical_prices_success" time="0.779" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_get_last_price_no_data" time="6.944" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_get_last_price_success" time="7.354" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_initialization_databento_unavailable" time="1.770" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_initialization_default_dates" time="0.774" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_initialization_success" time="0.783" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_mes_strategy_logic_simulation" time="0.787" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_parse_source_bars_empty_data" time="0.779" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_parse_source_bars_missing_columns" time="0.775" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_parse_source_bars_valid_data" time="0.780" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_timestep_mapping" time="0.779" /><testcase classname="tests.test_databento_data.TestDataBentoData" name="test_timezone_handling" time="0.785" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_build_cache_filename" time="0.776" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_cache_filename_edge_cases" time="0.776" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_cache_loading" time="0.789" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_continuous_futures_integration_edge_cases" time="0.770" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_continuous_futures_resolution" time="0.767" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_databento_client_initialization" time="0.751" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_dataframe_normalization_edge_cases" time="0.757" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_dataset_selection_comprehensive" time="0.759" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_determine_databento_dataset" time="0.755" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_determine_databento_schema" time="0.759" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_error_handling_api_exception" time="32.146" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_error_handling_empty_dataframe" time="24.807" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_format_futures_symbol_for_databento" time="0.721" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_futures_month_code_consistency" time="0.720" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_get_last_price_from_databento_empty_data" time="4.272" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_get_last_price_from_databento_exception" time="2.496" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_get_last_price_from_databento_no_data" time="2.274" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_get_last_price_from_databento_success" time="0.727" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_get_last_price_resolves_once_no_retry" time="2.503" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_get_price_data_continuous_futures_resolution" time="6.057" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_get_price_data_databento_unavailable" time="1.488" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_get_price_data_from_databento_success" time="1.469"><failure message="AssertionError: unexpectedly None">self = &lt;tests.test_databento_helper.TestDataBentoHelper testMethod=test_get_price_data_from_databento_success&gt;
mock_client_class = &lt;MagicMock name='DataBentoClient' id='18298037328'&gt;

    @patch('lumibot.tools.databento_helper.DATABENTO_AVAILABLE', True)
    @patch('lumibot.tools.databento_helper.DataBentoClient')
    def test_get_price_data_from_databento_success(self, mock_client_class):
        """Test successful data retrieval"""
        # Mock client and response
        mock_client_instance = Mock()
        mock_client_class.return_value = mock_client_instance
    
        # Create mock DataFrame response
        mock_df = pd.DataFrame({
            'ts_event': pd.to_datetime(['2025-01-01 09:30:00', '2025-01-01 09:31:00']),
            'open': [100.0, 101.0],
            'high': [102.0, 103.0],
            'low': [99.0, 100.0],
            'close': [101.0, 102.0],
            'volume': [1000, 1100]
        })
    
        mock_client_instance.get_historical_data.return_value = mock_df
    
        # Mock cache functions
        with patch('lumibot.tools.databento_helper._load_cache', return_value=None), \
             patch('lumibot.tools.databento_helper._save_cache') as mock_save:
    
            result = databento_helper.get_price_data_from_databento(
                api_key=self.api_key,
                asset=self.test_asset_future,
                start=self.start_date,
                end=self.end_date,
                timestep="minute"
            )
    
            # Verify result
&gt;           self.assertIsNotNone(result)
E           AssertionError: unexpectedly None

tests/test_databento_helper.py:165: AssertionError</failure></testcase><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_market_calendar_spanning_sessions" time="0.725" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_no_get_potential_futures_contracts_usage" time="0.730" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_no_retry_logic_for_correct_symbol" time="1.551"><failure message="AssertionError: unexpectedly None">self = &lt;tests.test_databento_helper.TestDataBentoHelper testMethod=test_no_retry_logic_for_correct_symbol&gt;
mock_client_class = &lt;MagicMock name='DataBentoClient' id='18290240320'&gt;

    @patch('lumibot.tools.databento_helper.DATABENTO_AVAILABLE', True)
    @patch('lumibot.tools.databento_helper.DataBentoClient')
    def test_no_retry_logic_for_correct_symbol(self, mock_client_class):
        """Test that the function uses correct symbol/dataset without retry logic"""
        # Mock client and response
        mock_client_instance = Mock()
        mock_client_class.return_value = mock_client_instance
    
        # Create mock DataFrame response
        mock_df = pd.DataFrame({
            'ts_event': pd.to_datetime(['2025-01-01 09:30:00', '2025-01-01 09:31:00']),
            'open': [100.0, 101.0],
            'high': [102.0, 103.0],
            'low': [99.0, 100.0],
            'close': [101.0, 102.0],
            'volume': [1000, 1100]
        })
    
        mock_client_instance.get_historical_data.return_value = mock_df
    
        # Mock cache functions
        with patch('lumibot.tools.databento_helper._load_cache', return_value=None), \
             patch('lumibot.tools.databento_helper._save_cache'):
    
            # Test with MES continuous futures
            mes_asset = Asset(symbol="MES", asset_type="future")
            result = databento_helper.get_price_data_from_databento(
                api_key=self.api_key,
                asset=mes_asset,
                start=self.start_date,
                end=self.end_date,
                timestep="minute"
            )
    
            # Verify result
&gt;           self.assertIsNotNone(result)
E           AssertionError: unexpectedly None

tests/test_databento_helper.py:259: AssertionError</failure></testcase><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_normalize_databento_dataframe" time="0.721" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_schema_mapping_comprehensive" time="0.721" /><testcase classname="tests.test_databento_helper.TestDataBentoHelper" name="test_timezone_aware_datetime_usage" time="0.721" /><testcase classname="tests.test_databento_helper.TestDataBentoAuthenticationRetry" name="test_403_forbidden_triggers_retry" time="0.721" /><testcase classname="tests.test_databento_helper.TestDataBentoAuthenticationRetry" name="test_auth_retry_logging" time="0.727" /><testcase classname="tests.test_databento_helper.TestDataBentoAuthenticationRetry" name="test_auth_retry_with_different_error_formats" time="0.725" /><testcase classname="tests.test_databento_helper.TestDataBentoAuthenticationRetry" name="test_authentication_retry_exhausts_after_max_retries" time="3.534" /><testcase classname="tests.test_databento_helper.TestDataBentoAuthenticationRetry" name="test_authentication_retry_on_401_error" time="0.726" /><testcase classname="tests.test_databento_helper.TestDataBentoAuthenticationRetry" name="test_client_property_lazy_initialization" time="0.725" /><testcase classname="tests.test_databento_helper.TestDataBentoAuthenticationRetry" name="test_client_recreation_on_auth_failure" time="2.300" /><testcase classname="tests.test_databento_helper.TestDataBentoAuthenticationRetry" name="test_non_auth_errors_not_retried" time="1.621" /><testcase classname="tests.test_databento_helper.TestDataBentoAuthenticationRetry" name="test_successful_retry_after_token_refresh" time="0.800" /><testcase classname="tests.test_databento_live" name="test_symbol_resolution" time="0.732" /><testcase classname="tests.test_databento_live" name="test_live_api_connection" time="1.462" /><testcase classname="tests.test_databento_live" name="test_minute_bar_aggregation" time="12.870" /><testcase classname="tests.test_databento_live" name="test_api_routing" time="0.775" /><testcase classname="tests.test_databento_live" name="test_long_time_periods" time="19.344" /><testcase classname="tests.test_databento_live" name="test_continuous_latency_monitoring" time="24.645" /><testcase classname="tests.test_databento_timezone_fixes.TestErrorLoggerFixes" name="test_error_logger_initialization" time="0.733" /><testcase classname="tests.test_databento_timezone_fixes.TestErrorLoggerFixes" name="test_error_logger_log_error_with_all_args" time="1.351" /><testcase classname="tests.test_databento_timezone_fixes.TestErrorLoggerFixes" name="test_error_logger_log_error_with_minimal_args" time="1.568" /><testcase classname="tests.test_databento_timezone_fixes.TestErrorLoggerFixes" name="test_error_logger_log_error_critical_levels" time="2.130" /><testcase classname="tests.test_databento_timezone_fixes.TestTimezoneHandling" name="test_timezone_naive_datetime_operations" time="0.736" /><testcase classname="tests.test_databento_timezone_fixes.TestTimezoneHandling" name="test_pandas_datetime_filtering" time="0.735" /><testcase classname="tests.test_databento_timezone_fixes.TestTimezoneHandling" name="test_datetime_timezone_consistency" time="0.737" /><testcase classname="tests.test_databento_timezone_fixes.TestTimezoneHandling" name="test_datetime_timezone_consistency_in_databento_context" time="0.752" /><testcase classname="tests.test_databento_timezone_fixes.TestDataBentoIntegration" name="test_databento_data_source_initialization" time="0.775" /><testcase classname="tests.test_databento_timezone_fixes.TestDataBentoIntegration" name="test_databento_futures_asset_validation" time="7.916" /><testcase classname="tests.test_databento_timezone_fixes.TestDataBentoIntegration" name="test_databento_live_trading_mode" time="0.800" /><testcase classname="tests.test_databento_timezone_fixes.TestDataBentoIntegration" name="test_databento_supported_asset_types" time="5.204" /><testcase classname="tests.test_databento_timezone_fixes.TestDataBentoTimezoneFixValidation" name="test_live_trading_datetime_handling" time="0.796" /><testcase classname="tests.test_databento_timezone_fixes.TestDataBentoTimezoneFixValidation" name="test_dataframe_timezone_operations" time="0.774" /><testcase classname="tests.test_databento_timezone_fixes" name="test_databento_api_integration[True]" time="0.777" /><testcase classname="tests.test_databento_timezone_fixes" name="test_databento_api_integration[False]" time="0.782"><skipped type="pytest.skip" message="DataBento API key not available">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_databento_timezone_fixes.py:275: DataBento API key not available</skipped></testcase><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_add_position" time="0.809" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_calculate_absolute_drift" time="0.812" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_calculate_relative_drift" time="0.838" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_drift_is_negative_one_when_we_have_a_position_and_the_target_weights_says_to_not_have_it" time="0.831" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_drift_is_one_when_we_have_none_of_an_asset_and_target_weights_says_we_should_have_some" time="0.783" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_drift_is_negative_one_when_we_have_none_of_an_asset_and_target_weights_says_we_should_short_some" time="0.819" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_drift_is_zero_when_current_weight_and_target_weight_are_zero" time="0.798" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_calculate_absolute_drift_when_quote_asset_position_exists" time="0.808" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_calculate_relative_drift_when_quote_asset_position_exists" time="0.799" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_calculate_absolute_drift_when_quote_asset_in_target_weights" time="0.802" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_calculate_drift_when_we_want_short_something" time="0.821" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_shorting_more_when_price_goes_up_short_something" time="0.824" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_calculate_absolute_drift_when_we_want_a_100_percent_short_position" time="0.795" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_calculate_absolute_drift_when_we_want_a_100_percent_short_position_and_cash_in_target_weights" time="0.782" /><testcase classname="tests.test_drift_rebalancer.TestDriftCalculationLogic" name="test_calculate_relative_drift_when_we_want_a_100_percent_short_position" time="0.796" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_selling_everything_with_limit_orders" time="0.792" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_selling_everything_with_market_orders" time="0.797" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_selling_part_of_a_holding_with_limit_order" time="0.800" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_selling_with_only_rebalance_drifted_assets_when_over_drift_threshold" time="0.805" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_selling_with_only_rebalance_drifted_assets_when_not_over_drift_threshold" time="0.797" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_selling_part_of_a_holding_with_market_order" time="0.787" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_selling_short_doesnt_create_and_order_when_shorting_is_disabled" time="0.788" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_selling_small_short_position_creates_and_order_when_shorting_is_enabled" time="0.791" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_selling_small_short_position_doesnt_create_order_when_shorting_is_disabled" time="0.815" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_selling_a_100_percent_short_position_creates_an_order_when_shorting_is_enabled" time="0.788" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_buying_something_when_we_have_enough_money_and_there_is_slippage" time="0.789" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_limit_buy_when_we_dont_have_enough_money_for_everything" time="0.784" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_market_buy_when_we_dont_have_enough_money_for_everything" time="0.818" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_attempting_to_buy_when_we_dont_have_enough_money_for_even_one_share" time="0.787" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_attempting_to_sell_when_the_amount_we_need_to_sell_is_less_than_the_limit_price_should_not_sell" time="0.811" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_calculate_limit_price_when_selling" time="0.790" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_calculate_limit_price_when_buying" time="0.804" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_buying_whole_shares" time="0.796" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_buying_fractional_shares" time="0.806" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_selling_everything_with_fractional_limit_orders" time="0.798" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_selling_some_with_fractional_limit_orders" time="0.814" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_buying_with_only_rebalance_drifted_assets_when_over_drift_threshold" time="0.812" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_buying_with_only_rebalance_drifted_assets_when_not_over_drift_threshold" time="0.830" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_calculate_trading_costs_with_percent_fees" time="0.782" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_calculate_trading_costs_with_flat_fees" time="0.817" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_calculate_trading_costs_with_both_fee_types" time="0.802" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_calculate_trading_costs_no_fees" time="0.815" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_adjust_quantity_for_fees_buy_affordable" time="0.812" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_adjust_quantity_for_fees_buy_not_affordable" time="0.796" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_adjust_quantity_for_fees_sell" time="0.797" /><testcase classname="tests.test_drift_rebalancer.TestDriftOrderLogic" name="test_get_current_cash_position" time="0.808" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancer" name="test_even_odd_drift_rebalancer_absolute" time="1.253" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancer" name="test_even_odd_drift_rebalancer_relative" time="1.235" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancer" name="test_classic_60_40" time="1.092" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancer" name="test_classic_60_40_with_fractional" time="1.113" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancer" name="test_crypto_50_50_with_yahoo" time="5.537"><skipped type="pytest.xfail" message="yahoo sucks" /></testcase><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancer" name="test_crypto_50_50_with_polygon" time="4.414" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancer" name="test_crypto_50_50_with_alpaca" time="1.100" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancer" name="test_crypto_50_50_with_alpaca_modern_way" time="0.982" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancer" name="test_crypto_50_50_with_alpaca_with_fees" time="0.996" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancer" name="test_get_last_price_or_raise_returns_decimal" time="0.853" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancer" name="test_get_last_price_or_raise_raises_value_error_on_none" time="0.844" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancerOptions" name="test_buying_options_with_correct_quantity_calculation" time="0.861" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancerOptions" name="test_buying_options_respects_cash_constraints" time="0.888" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancerOptions" name="test_selling_options_with_correct_quantity_calculation" time="0.872" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancerOptions" name="test_options_quantity_always_whole_contracts" time="0.864" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancerOptions" name="test_mixed_stocks_and_options_portfolio" time="0.895" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancerOptions" name="test_options_cost_calculation_in_cash_deduction" time="0.873" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancerOptions" name="test_options_limit_price_calculation" time="0.859" /><testcase classname="tests.test_drift_rebalancer.TestDriftRebalancerOptions" name="test_options_insufficient_cash_creates_no_order" time="0.890" /><testcase classname="tests.test_futures_integration.TestFuturesCycleAlgoIntegration" name="test_no_position_triggers_buy" time="0.875" /><testcase classname="tests.test_futures_integration.TestFuturesCycleAlgoIntegration" name="test_tradovate_position_detected" time="0.859" /><testcase classname="tests.test_futures_integration.TestFuturesCycleAlgoIntegration" name="test_tradovate_position_sells_after_minute" time="0.850" /><testcase classname="tests.test_futures_integration.TestFuturesCycleAlgoIntegration" name="test_ib_style_position_detected" time="0.865" /><testcase classname="tests.test_futures_integration.TestFuturesCycleAlgoIntegration" name="test_multiple_contracts_logs_warning" time="0.903" /><testcase classname="tests.test_futures_integration.TestFuturesCycleAlgoIntegration" name="test_ignores_other_futures" time="0.860" /><testcase classname="tests.test_futures_integration.TestFuturesCycleAlgoIntegration" name="test_ignores_stock_positions" time="0.884" /><testcase classname="tests.test_get_historical_prices.TestBacktestingDataSources" name="test_get_first_trading_day_after_long_weekend" time="0.849" /><testcase classname="tests.test_get_historical_prices.TestBacktestingDataSources" name="test_pandas_backtesting_data_source_get_historical_prices_daily_bars_dividends_and_adj_returns" time="0.891" /><testcase classname="tests.test_get_historical_prices.TestBacktestingDataSources" name="test_polygon_backtesting_data_source_get_historical_prices_daily_bars_for_backtesting_broker" time="0.948"><skipped type="pytest.skip" message="Polygon API returned no data - possibly due to rate limits, invalid API key, or data availability">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_get_historical_prices.py:154: Polygon API returned no data - possibly due to rate limits, invalid API key, or data availability</skipped></testcase><testcase classname="tests.test_get_historical_prices.TestBacktestingDataSources" name="test_polygon_backtesting_data_source_get_historical_prices_daily_bars_over_long_weekend" time="0.960"><skipped type="pytest.skip" message="Polygon API returned no data - possibly due to rate limits, invalid API key, or data availability">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_get_historical_prices.py:181: Polygon API returned no data - possibly due to rate limits, invalid API key, or data availability</skipped></testcase><testcase classname="tests.test_get_historical_prices.TestBacktestingDataSources" name="test_yahoo_backtesting_data_source_get_historical_prices_daily_bars_dividends_and_adj_returns" time="0.872" /><testcase classname="tests.test_get_historical_prices.TestBacktestingDataSources" name="test_kraken_ccxt_backtesting_data_source_get_historical_prices_daily_bars" time="0.000"><skipped type="pytest.skip" message="CCXT Kraken integration test requires stable network connection and external API availability">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_get_historical_prices.py:208: CCXT Kraken integration test requires stable network connection and external API availability</skipped></testcase><testcase classname="tests.test_get_historical_prices.TestTimestepParsing" name="test_parse_timestep_standard_formats" time="0.862" /><testcase classname="tests.test_get_historical_prices.TestTimestepParsing" name="test_parse_timestep_multi_minute_formats" time="0.863" /><testcase classname="tests.test_get_historical_prices.TestTimestepParsing" name="test_parse_timestep_hour_formats" time="0.865" /><testcase classname="tests.test_get_historical_prices.TestTimestepParsing" name="test_parse_timestep_day_week_month_formats" time="0.850" /><testcase classname="tests.test_get_historical_prices.TestTimestepParsing" name="test_parse_timestep_case_insensitive" time="0.854" /><testcase classname="tests.test_get_historical_prices.TestTimestepParsing" name="test_parse_timestep_invalid_formats" time="0.872" /><testcase classname="tests.test_helpers" name="test_has_more_than_n_decimal_places" time="0.854" /><testcase classname="tests.test_helpers" name="test_date_n_bars_from_date_valid_input" time="1.229" /><testcase classname="tests.test_helpers" name="test_date_n_bars_from_date_zero_bars" time="0.846" /><testcase classname="tests.test_helpers" name="test_date_n_trading_days_from_date_with_24_7_market" time="0.845" /><testcase classname="tests.test_helpers" name="test_get_trading_days" time="0.905" /><testcase classname="tests.test_helpers" name="test_get_trading_times_day_nyse" time="0.970" /><testcase classname="tests.test_helpers" name="test_get_trading_times_minute_nyse" time="0.862" /><testcase classname="tests.test_helpers" name="test_get_trading_times_minute_24_7_utc" time="0.871" /><testcase classname="tests.test_helpers" name="test_get_trading_times_minute_24_7_UTC" time="0.863" /><testcase classname="tests.test_helpers" name="test_get_trading_times_minute" time="0.951" /><testcase classname="tests.test_helpers" name="test_get_timezone_from_datetime" time="0.875" /><testcase classname="tests.test_helpers" name="test_get_timezone_from_datetime_types" time="0.865" /><testcase classname="tests.test_helpers" name="test_quantize_to_num_decimals" time="0.870" /><testcase classname="tests.test_helpers" name="test_is_market_open_during_trading_hours" time="0.933" /><testcase classname="tests.test_helpers" name="test_is_market_open_before_trading_hours" time="0.934" /><testcase classname="tests.test_helpers" name="test_is_market_open_after_trading_hours" time="0.938" /><testcase classname="tests.test_helpers" name="test_is_market_open_weekend" time="0.970" /><testcase classname="tests.test_helpers" name="test_is_market_open_invalid_market" time="0.855" /><testcase classname="tests.test_indicator_subplots.TestIndicators" name="test_default_lines" time="6.590" /><testcase classname="tests.test_indicator_subplots.TestIndicators" name="test_named_lines" time="7.293" /><testcase classname="tests.test_indicator_subplots" name="test_plot_indicators_handles_nan_marker_size" time="1.157" /><testcase classname="tests.test_indicator_subplots.TestAddMarkerAndLineGuards" name="test_add_marker_rejects_nan" time="0.877" /><testcase classname="tests.test_indicator_subplots.TestAddMarkerAndLineGuards" name="test_add_marker_defaults_color" time="0.882" /><testcase classname="tests.test_indicator_subplots.TestAddMarkerAndLineGuards" name="test_add_marker_accepts_css_color" time="0.904" /><testcase classname="tests.test_indicator_subplots.TestAddMarkerAndLineGuards" name="test_add_line_rejects_nan" time="0.891" /><testcase classname="tests.test_indicator_subplots.TestAddMarkerAndLineGuards" name="test_add_line_defaults_color" time="0.874" /><testcase classname="tests.test_indicator_subplots.TestAddMarkerAndLineGuards" name="test_add_line_defaults_style" time="0.898" /><testcase classname="tests.test_integration_tests.TestIntegrationTests" name="test_yahoo" time="5.965" /><testcase classname="tests.test_interactive_brokers" name="test_initialize_interactive_broker_legacy" time="36.199" /><testcase classname="tests.test_live_trading_resilience.TestLiveTradingResilience" name="test_live_trading_resilience_is_working" time="11.032" /><testcase classname="tests.test_logger_env_vars.TestEnvironmentVariableHandling" name="test_backtesting_quiet_logs_overrides_log_level" time="0.933" /><testcase classname="tests.test_logger_env_vars.TestEnvironmentVariableHandling" name="test_env_var_precedence_documentation" time="0.915" /><testcase classname="tests.test_logger_env_vars.TestEnvironmentVariableHandling" name="test_memory_usage_is_minimal" time="0.889" /><testcase classname="tests.test_logging.TestLogging" name="test_logging" time="0.881" /><testcase classname="tests.test_logging.TestLogging" name="test_backtest_produces_no_logs_when_quiet_logs_is_true" time="7.269"><skipped type="pytest.xfail" message="yahoo sucks" /></testcase><testcase classname="tests.test_logging.TestLogging" name="test_backtest_produces_logs_when_quiet_logs_is_false" time="6.048"><skipped type="pytest.xfail" message="yahoo sucks" /></testcase><testcase classname="tests.test_lumibot_logger" name="test_unified_logger_includes_source_context" time="0.927" /><testcase classname="tests.test_lumibot_logger" name="test_unified_logger_info_includes_module_context" time="0.920" /><testcase classname="tests.test_lumibot_logger" name="test_file_handler_uses_lumibot_formatter" time="0.912" /><testcase classname="tests.test_lumibot_logger" name="test_quiet_logs_functionality" time="0.930" /><testcase classname="tests.test_lumibot_logger" name="test_trader_quiet_logs_integration" time="0.921" /><testcase classname="tests.test_market_infinite_loop_bug.TestESFuturesHangBug" name="test_comprehensive_diagnostic_scenarios" time="1.799" /><testcase classname="tests.test_market_infinite_loop_bug.TestESFuturesHangBug" name="test_continuous_vs_non_continuous_markets" time="1.083" /><testcase classname="tests.test_market_infinite_loop_bug.TestESFuturesHangBug" name="test_different_market_types" time="1.095" /><testcase classname="tests.test_market_infinite_loop_bug.TestESFuturesHangBug" name="test_different_sleeptime_combinations" time="1.647" /><testcase classname="tests.test_market_infinite_loop_bug.TestESFuturesHangBug" name="test_es_futures_no_infinite_restart" time="7.286" /><testcase classname="tests.test_mes_symbols.TestMESSymbols" name="test_mes_symbol_availability" time="13.108"><skipped type="pytest.skip" message="No MES symbols available in DataBento (API or data issue). Tested: ['MES', 'MES1!', 'MES.c.0', 'MESU5', 'MES.U5', 'MESZ4', 'MES.Z4', 'MESH5', 'MES.H5']">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_mes_symbols.py:77: No MES symbols available in DataBento (API or data issue). Tested: ['MES', 'MES1!', 'MES.c.0', 'MESU5', 'MES.U5', 'MESZ4', 'MES.Z4', 'MESH5', 'MES.H5']</skipped></testcase><testcase classname="tests.test_momentum.TestMomentum" name="test_momo_pandas_lookback_2" time="5.555" /><testcase classname="tests.test_momentum.TestMomentum" name="test_momo_pandas_lookback_30" time="5.266" /><testcase classname="tests.test_momentum.TestMomentum" name="test_momo_yahoo_lookback_2" time="5.935" /><testcase classname="tests.test_momentum.TestMomentum" name="test_momo_yahoo_lookback_30" time="5.901"><skipped type="pytest.xfail" message="yahoo sucks" /></testcase><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_broker_get_chains_handles_missing_payload" time="1.091" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_chains_backward_compatibility_string_access" time="1.061" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_chains_date_helper_methods" time="1.160" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_chains_strikes_accepts_both_string_and_date" time="1.140" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_enhanced_logging_format" time="1.057" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_evaluate_option_market_fallback_allowed" time="1.105" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_evaluate_option_market_fallback_blocked" time="1.071" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_evaluate_option_market_with_quotes" time="1.045" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_find_next_valid_option_checks_quote_first" time="1.082"><failure message="AssertionError: unexpectedly None">self = &lt;tests.test_options_helper.TestOptionsHelper testMethod=test_find_next_valid_option_checks_quote_first&gt;

    def test_find_next_valid_option_checks_quote_first(self):
        """Test that find_next_valid_option checks quote before last_price"""
        underlying_asset = Asset("TEST", asset_type="stock")
        expiry = date.today() + timedelta(days=30)
    
        # Mock get_quote to return valid quote
        mock_quote = Mock()
        mock_quote.bid = 2.0
        mock_quote.ask = 2.5
        self.mock_strategy.get_quote = Mock(return_value=mock_quote)
        self.mock_strategy.get_last_price = Mock(return_value=None)
    
        result = self.options_helper.find_next_valid_option(
            underlying_asset=underlying_asset,
            rounded_underlying_price=200.0,
            expiry=expiry,
            put_or_call="call"
        )
    
        # Should find option based on quote, even though last_price is None
&gt;       self.assertIsNotNone(result)
E       AssertionError: unexpectedly None

tests/test_options_helper.py:419: AssertionError</failure></testcase><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_find_next_valid_option_falls_back_to_last_price" time="1.108"><failure message="AssertionError: Expected 'get_quote' to have been called.">self = &lt;Mock name='mock.get_quote' id='20926619456'&gt;

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
&gt;           raise AssertionError(msg)
E           AssertionError: Expected 'get_quote' to have been called.

/opt/homebrew/Cellar/python@3.12/3.12.10/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;tests.test_options_helper.TestOptionsHelper testMethod=test_find_next_valid_option_falls_back_to_last_price&gt;

    def test_find_next_valid_option_falls_back_to_last_price(self):
        """Test fallback to last_price when quote has no bid/ask"""
        underlying_asset = Asset("TEST", asset_type="stock")
        expiry = date.today() + timedelta(days=30)
    
        # Mock get_quote to return quote with None bid/ask
        mock_quote = Mock()
        mock_quote.bid = None
        mock_quote.ask = None
        self.mock_strategy.get_quote = Mock(return_value=mock_quote)
        self.mock_strategy.get_last_price = Mock(return_value=2.25)
    
        result = self.options_helper.find_next_valid_option(
            underlying_asset=underlying_asset,
            rounded_underlying_price=200.0,
            expiry=expiry,
            put_or_call="put"
        )
    
        # Should find option based on last_price fallback
        self.assertIsNotNone(result)
&gt;       self.mock_strategy.get_quote.assert_called()
E       AssertionError: Expected 'get_quote' to have been called.

tests/test_options_helper.py:447: AssertionError</failure></testcase><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_get_expiration_on_or_after_date_returns_future" time="1.053" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_get_expiration_on_or_after_date_uses_latest_when_needed" time="1.101" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_get_expiration_validates_data_when_underlying_provided" time="1.102" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_invalid_delta" time="1.099" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_invalid_underlying_price" time="1.057" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_missing_chains_returns_none" time="1.104" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_normal_strike_calculation" time="1.065" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_normalize_option_chains_adds_missing_keys" time="1.128" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_normalize_option_chains_invalid_expiry" time="1.087" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_options_expiry_to_datetime_date_accepts_strings" time="1.078" /><testcase classname="tests.test_options_helper.TestOptionsHelper" name="test_warning_for_unrealistic_strike" time="1.046" /><testcase classname="tests.test_order.TestOrderBasics" name="test_side_must_be_one_of" time="1.078" /><testcase classname="tests.test_order.TestOrderBasics" name="test_blank_oco" time="1.073" /><testcase classname="tests.test_order.TestOrderBasics" name="test_price_doesnt_exist" time="1.069" /><testcase classname="tests.test_order.TestOrderBasics" name="test_is_option" time="1.075" /><testcase classname="tests.test_order.TestOrderBasics" name="test_get_filled_price" time="1.062" /><testcase classname="tests.test_order.TestOrderBasics" name="test_filled" time="1.060" /><testcase classname="tests.test_order.TestOrderBasics" name="test_is_buy_order" time="1.114" /><testcase classname="tests.test_order.TestOrderBasics" name="test_is_sell_order" time="1.057" /><testcase classname="tests.test_order.TestOrderBasics" name="test_cancelled" time="1.069" /><testcase classname="tests.test_order.TestOrderBasics" name="test_active" time="1.059" /><testcase classname="tests.test_order.TestOrderBasics" name="test_active_oco" time="1.132" /><testcase classname="tests.test_order.TestOrderBasics" name="test_status" time="1.078" /><testcase classname="tests.test_order.TestOrderBasics" name="test_equivalent_status" time="1.069" /><testcase classname="tests.test_order.TestOrderBasics" name="test_to_position" time="1.097" /><testcase classname="tests.test_order.TestOrderAdvanced" name="test_oco_type_reassigned" time="1.079" /><testcase classname="tests.test_order.TestOrderAdvanced" name="test_bracket_standard" time="1.145" /><testcase classname="tests.test_order.TestOrderAdvanced" name="test_is_equivalent_status" time="1.063" /><testcase classname="tests.test_order_serialization.TestOrderSerialization" name="test_to_dict_excludes_internal_fields" time="1.067" /><testcase classname="tests.test_order_serialization.TestOrderSerialization" name="test_to_dict_includes_essential_fields" time="1.057" /><testcase classname="tests.test_order_serialization.TestOrderSerialization" name="test_to_dict_size_reduction" time="1.078" /><testcase classname="tests.test_pandas_data.TestPandasData" name="test_pandas_data_fixture" time="1.134" /><testcase classname="tests.test_pandas_data.TestPandasData" name="test_spy_has_dividends" time="1.099" /><testcase classname="tests.test_pandas_data.TestPandasData" name="test_get_start_datetime_and_ts_unit" time="1.099" /><testcase classname="tests.test_pandas_data.TestPandasData" name="test_data_get_quote_handles_missing_bid_ask" time="1.074" /><testcase classname="tests.test_polygon_helper.TestPolygonHelpers" name="test_build_cache_filename" time="1.092" /><testcase classname="tests.test_polygon_helper.TestPolygonHelpers" name="test_missing_dates" time="1.203" /><testcase classname="tests.test_polygon_helper.TestPolygonHelpers" name="test_get_trading_dates" time="1.195" /><testcase classname="tests.test_polygon_helper.TestPolygonHelpers" name="test_get_polygon_symbol" time="1.107" /><testcase classname="tests.test_polygon_helper.TestPolygonHelpers" name="test_load_data_from_cache" time="1.116" /><testcase classname="tests.test_polygon_helper.TestPolygonHelpers" name="test_update_cache" time="1.122" /><testcase classname="tests.test_polygon_helper.TestPolygonHelpers" name="test_update_polygon_data" time="1.091" /><testcase classname="tests.test_polygon_helper.TestPolygonPriceData" name="test_get_price_data_from_polygon" time="1.143" /><testcase classname="tests.test_polygon_helper.TestPolygonPriceData" name="test_polygon_missing_day_caching[True-day]" time="1.062" /><testcase classname="tests.test_polygon_helper.TestPolygonPriceData" name="test_polygon_missing_day_caching[True-minute]" time="1.082" /><testcase classname="tests.test_polygon_helper.TestPolygonPriceData" name="test_polygon_missing_day_caching[False-day]" time="1.093" /><testcase classname="tests.test_polygon_helper.TestPolygonPriceData" name="test_polygon_missing_day_caching[False-minute]" time="1.063" /><testcase classname="tests.test_polygon_helper.TestPolygonPriceData" name="test_get_chains_cached" time="1.065" /><testcase classname="tests.test_position_serialization.TestPositionSerialization" name="test_orders_list_included" time="1.060" /><testcase classname="tests.test_position_serialization.TestPositionSerialization" name="test_to_dict_excludes_internal_fields" time="1.080" /><testcase classname="tests.test_position_serialization.TestPositionSerialization" name="test_to_dict_includes_essential_fields" time="1.076" /><testcase classname="tests.test_position_serialization.TestPositionSerialization" name="test_to_dict_size_reduction" time="1.096" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_broker_initialization" time="1.078" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_order_status_mapping_corrected" time="1.089" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_position_conversion_field_mapping" time="1.055" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_position_conversion_field_fallback" time="1.107" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_order_conversion_from_broker_format" time="1.072" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_order_status_mapping_edge_cases" time="1.092" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_asset_resolution_no_hardcoded_mappings" time="1.089" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_order_tracking_sync_functionality" time="1.074" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_order_sync_prevents_auto_cancellation" time="1.084" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_get_historical_account_value_not_implemented" time="1.071" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_get_option_chains_not_supported" time="1.083" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_order_type_conversions" time="1.076" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_contract_id_parsing" time="1.104" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_logging_cleanup" time="1.097" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_position_display_format" time="1.131" /><testcase classname="tests.test_projectx.TestProjectXBroker" name="test_multiple_order_status_scenarios" time="1.038" /><testcase classname="tests.test_projectx.TestProjectXBrokerIntegration" name="test_full_order_sync_workflow" time="1.013" /><testcase classname="tests.test_projectx.TestProjectXBrokerIntegration" name="test_position_sync_workflow" time="0.998" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_create_bracket_meta_shape" time="1.122" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_normalize_bracket_entry_tag[MYTAG-BRK_ENTRY_MYTAG-MYTAG]" time="1.150" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_normalize_bracket_entry_tag[BRK_ENTRY_BASE-BRK_ENTRY_BASE-BASE]" time="1.028" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_normalize_bracket_entry_tag[BRK_TP_BASE-BRK_ENTRY_BASE-BASE]" time="0.990" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_normalize_bracket_entry_tag[BRK_STOP_BASE-BRK_ENTRY_BASE-BASE]" time="0.989" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_normalize_bracket_entry_tag[None-None-None]" time="1.053" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_derive_base_tag[BRK_ENTRY_BASE-BASE]" time="1.060" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_derive_base_tag[BRK_TP_BASE-BASE]" time="1.037" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_derive_base_tag[BRK_STOP_BASE-BASE]" time="1.061" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_derive_base_tag[PLAIN-PLAIN]" time="1.028" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_derive_base_tag[None-None]" time="0.991" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_bracket_child_tag_variants" time="0.991" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_build_unique_order_tag_generates_and_preserves" time="0.997" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_select_effective_prices_precedence_and_rounding" time="0.992" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_early_store_and_restore_bracket_meta" time="0.998" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_should_spawn_bracket_children[meta0-False-expected0]" time="1.011" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_should_spawn_bracket_children[meta1-False-expected1]" time="0.989" /><testcase classname="tests.test_projectx_bracket_helpers" name="test_build_bracket_child_spec_shapes" time="0.990" /><testcase classname="tests.test_projectx_bracket_lifecycle_unit" name="test_bracket_parent_submission_stores_meta_and_normalizes_tag" time="0.998" /><testcase classname="tests.test_projectx_bracket_lifecycle_unit" name="test_bracket_children_spawn_on_fill_and_tagging" time="0.993" /><testcase classname="tests.test_projectx_bracket_lifecycle_unit" name="test_bracket_child_fill_cancels_sibling" time="0.999" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_data_source_initialization" time="0.991" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_asset_to_contract_id_no_hardcoded_mappings" time="0.992" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_contract_id_generation_dynamic" time="0.987" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_timespan_parsing" time="0.989" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_projectx_unit_mapping" time="0.994" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_get_historical_prices_bars_conversion" time="1.003" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_get_last_price" time="0.999" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_dividends_not_supported" time="0.990" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_option_chains_not_supported" time="1.004" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_get_bars_with_contract_found" time="0.986" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_contract_search_multiple_formats" time="0.984" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_error_handling_no_contracts_found" time="0.983" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_get_contract_details" time="0.982" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_search_contracts" time="1.004" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_get_quote" time="0.984" /><testcase classname="tests.test_projectx_data.TestProjectXDataSource" name="test_get_bars_from_datetime" time="0.985" /><testcase classname="tests.test_projectx_data.TestProjectXDataSourceIntegration" name="test_full_historical_data_workflow" time="0.984" /><testcase classname="tests.test_projectx_data.TestProjectXDataSourceIntegration" name="test_asset_resolution_workflow_with_fallbacks" time="0.993" /><testcase classname="tests.test_projectx_datetime_columns" name="test_projectx_fetch_bars_datetime_debug" time="0.987" /><testcase classname="tests.test_projectx_datetime_index" name="test_projectx_datetime_index" time="0.985" /><testcase classname="tests.test_projectx_helpers.TestProjectXAuth" name="test_get_auth_token_success" time="0.988" /><testcase classname="tests.test_projectx_helpers.TestProjectXAuth" name="test_get_auth_token_failure" time="0.982" /><testcase classname="tests.test_projectx_helpers.TestProjectXAuth" name="test_get_auth_token_invalid_json" time="0.985" /><testcase classname="tests.test_projectx_helpers.TestProjectXAuth" name="test_get_auth_token_missing_config" time="0.995" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_client_initialization" time="0.984" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_get_accounts" time="0.997" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_get_preferred_account_id" time="1.001" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_get_account_balance" time="0.989" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_get_positions" time="0.997" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_get_orders" time="0.993" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_place_order_success" time="1.003" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_cancel_order_success" time="0.986" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_get_historical_data" time="0.984" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_search_contracts" time="0.985" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_get_contract_details" time="0.987" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_find_contract_by_symbol" time="0.981" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_contract_id_conversion_no_hardcoded_mappings" time="0.992" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_get_contract_tick_size" time="0.989" /><testcase classname="tests.test_projectx_helpers.TestProjectXClient" name="test_round_to_tick_size" time="0.986" /><testcase classname="tests.test_projectx_helpers.TestProjectXApiClient" name="test_api_client_initialization" time="0.982" /><testcase classname="tests.test_projectx_helpers.TestProjectXApiClient" name="test_api_request_headers" time="0.983" /><testcase classname="tests.test_projectx_helpers.TestProjectXApiClient" name="test_account_search" time="0.997" /><testcase classname="tests.test_projectx_helpers.TestProjectXApiClient" name="test_position_search_open" time="1.054" /><testcase classname="tests.test_projectx_helpers.TestProjectXApiClient" name="test_order_search" time="1.060" /><testcase classname="tests.test_projectx_helpers.TestProjectXApiClient" name="test_order_place" time="0.985" /><testcase classname="tests.test_projectx_helpers.TestProjectXApiClient" name="test_order_cancel" time="0.986" /><testcase classname="tests.test_projectx_helpers.TestProjectXApiClient" name="test_contract_search" time="1.004" /><testcase classname="tests.test_projectx_helpers.TestProjectXApiClient" name="test_contract_search_id" time="1.078" /><testcase classname="tests.test_projectx_helpers.TestProjectXApiClient" name="test_history_retrieve_bars" time="1.002" /><testcase classname="tests.test_projectx_helpers.TestProjectXApiClient" name="test_get_streaming_client" time="0.988" /><testcase classname="tests.test_projectx_helpers.TestProjectXErrorHandling" name="test_authentication_retry_logic" time="0.986" /><testcase classname="tests.test_projectx_helpers.TestProjectXErrorHandling" name="test_api_rate_limiting_handling" time="1.005" /><testcase classname="tests.test_projectx_helpers.TestProjectXErrorHandling" name="test_network_error_handling" time="0.989" /><testcase classname="tests.test_projectx_helpers.TestProjectXErrorHandling" name="test_invalid_response_handling" time="1.546" /><testcase classname="tests.test_projectx_helpers.TestProjectXErrorHandling" name="test_http_error_codes" time="7.512" /><testcase classname="tests.test_projectx_lifecycle" name="test_projectx_initialization" time="0.993" /><testcase classname="tests.test_projectx_lifecycle" name="test_projectx_has_client" time="0.996" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_submit_and_cancel" time="1.009" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_rejection_mapping_max_position" time="0.991" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_rejection_generic" time="0.992" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_new_order_event_dispatched_on_submit" time="0.999" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_order_status_change_detection" time="1.007" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_order_cancellation_event" time="0.993" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_partial_fill_event" time="0.989" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_streaming_order_update_triggers_events" time="0.988" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_streaming_trade_update_triggers_fill" time="0.996" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_pre_existing_filled_order_handling" time="0.999" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_error_order_event" time="0.987" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_order_identifier_sync" time="0.989" /><testcase classname="tests.test_projectx_lifecycle_unit" name="test_order_tracking_with_multiple_orders" time="0.997" /><testcase classname="tests.test_projectx_timestep_alias" name="test_projectx_get_bars_accepts_timestep_alias" time="1.208" /><testcase classname="tests.test_projectx_url_mappings.TestProjectXURLMappings" name="test_url_mappings_loaded" time="0.991" /><testcase classname="tests.test_projectx_url_mappings.TestProjectXURLMappings" name="test_url_patterns" time="1.016" /><testcase classname="tests.test_projectx_url_mappings.TestProjectXURLMappings" name="test_get_config_with_builtin_urls" time="1.038" /><testcase classname="tests.test_projectx_url_mappings.TestProjectXURLMappings" name="test_get_config_with_env_override" time="1.002" /><testcase classname="tests.test_projectx_url_mappings.TestProjectXURLMappings" name="test_get_config_partial_env_override" time="1.001" /><testcase classname="tests.test_projectx_url_mappings.TestProjectXURLMappings" name="test_get_config_topstepx_special_case" time="1.007" /><testcase classname="tests.test_projectx_url_mappings.TestProjectXURLMappings" name="test_get_config_unknown_firm" time="1.002" /><testcase classname="tests.test_projectx_url_mappings.TestProjectXURLMappings" name="test_auto_detection_with_multiple_firms" time="0.998" /><testcase classname="tests.test_projectx_url_mappings.TestProjectXBrokerValidation" name="test_broker_validation_success" time="1.011" /><testcase classname="tests.test_projectx_url_mappings.TestProjectXBrokerValidation" name="test_broker_validation_missing_fields" time="1.011" /><testcase classname="tests.test_projectx_url_mappings.TestProjectXBrokerValidation" name="test_short_firm_name_env_vars_only" time="1.005" /><testcase classname="tests.test_projectx_url_mappings.TestProjectXBrokerValidation" name="test_no_legacy_firm_names_in_mappings" time="1.017" /><testcase classname="tests.test_quiet_logs_buy_and_hold" name="test_quiet_logs_buy_and_hold_integration" time="1.014" /><testcase classname="tests.test_quiet_logs_comprehensive" name="test_print_progress_bar_respects_quiet_logs" time="1.026" /><testcase classname="tests.test_quiet_logs_comprehensive" name="test_data_source_backtesting_respects_quiet_logs" time="0.999" /><testcase classname="tests.test_quiet_logs_comprehensive" name="test_strategy_logger_respects_quiet_logs" time="1.035" /><testcase classname="tests.test_quiet_logs_comprehensive" name="test_environment_variable_variations" time="1.026" /><testcase classname="tests.test_quiet_logs_functionality" name="test_progress_bar_always_shows_with_quiet_logs" time="1.008" /><testcase classname="tests.test_quiet_logs_functionality" name="test_strategy_logger_respects_quiet_logs" time="1.018" /><testcase classname="tests.test_quiet_logs_functionality" name="test_quiet_logs_environment_variable" time="1.007" /><testcase classname="tests.test_quiet_logs_functionality" name="test_progress_bar_shows_green_bar" time="1.017" /><testcase classname="tests.test_quiet_logs_requirements.TestQuietLogsRequirements" name="test_requirement_1_console_always_error_during_backtest_quiet_true" time="1.021" /><testcase classname="tests.test_quiet_logs_requirements.TestQuietLogsRequirements" name="test_requirement_1_console_always_error_during_backtest_quiet_false" time="1.010" /><testcase classname="tests.test_quiet_logs_requirements.TestQuietLogsRequirements" name="test_requirement_2_file_logging_quiet_true" time="1.024" /><testcase classname="tests.test_quiet_logs_requirements.TestQuietLogsRequirements" name="test_requirement_2_file_logging_quiet_false" time="1.005" /><testcase classname="tests.test_quiet_logs_requirements.TestQuietLogsRequirements" name="test_requirement_3_live_trading_unaffected" time="1.008" /><testcase classname="tests.test_quiet_logs_requirements.TestQuietLogsRequirements" name="test_trader_integration_quiet_logs_false" time="1.004" /><testcase classname="tests.test_quiet_logs_requirements.TestQuietLogsRequirements" name="test_default_backtesting_quiet_logs_is_true" time="0.992" /><testcase classname="tests.test_session_manager.TestSessionManager" name="test_backtesting_session_guarantees_time_progression" time="0.998" /><testcase classname="tests.test_session_manager.TestSessionManager" name="test_backtesting_session_prevents_infinite_restart" time="1.001" /><testcase classname="tests.test_session_manager.TestSessionManager" name="test_data_source_agnostic_design" time="1.005" /><testcase classname="tests.test_session_manager.TestSessionManager" name="test_live_trading_session_time_management" time="1.004" /><testcase classname="tests.test_session_manager.TestSessionManager" name="test_session_architecture_separation_of_concerns" time="1.139" /><testcase classname="tests.test_session_manager.TestSessionManager" name="test_session_replaces_problematic_run_trading_session" time="1.048" /><testcase classname="tests.test_strategy_methods.TestStrategyMethods" name="test_get_option_expiration_after_date" time="1.235" /><testcase classname="tests.test_strategy_methods.TestStrategyMethods" name="test_validate_order_with_none_quantity" time="1.108" /><testcase classname="tests.test_strategy_methods.TestStrategyMethods" name="test_validate_order_with_zero_quantity" time="1.065" /><testcase classname="tests.test_strategy_methods.TestStrategyMethods" name="test_validate_order_with_valid_quantity" time="1.033" /><testcase classname="tests.test_strategy_methods.TestStrategyMethods" name="test_validate_order_with_none_order" time="1.013" /><testcase classname="tests.test_strategy_methods.TestStrategyMethods" name="test_validate_order_with_invalid_order_type" time="1.052" /><testcase classname="tests.test_strategy_methods.TestStrategyMethods" name="test_register_cron_callback_returns_job_id" time="1.066" /><testcase classname="tests.test_strategy_methods.TestStrategyMethods" name="test_update_portfolio_value_with_missing_price" time="1.036" /><testcase classname="tests.test_strategy_methods.TestStrategyMethods" name="test_register_cron_callback_adds_job_to_scheduler" time="1.043" /><testcase classname="tests.test_strategy_methods.TestStrategyMethods" name="test_register_cron_callback_uses_broker_timezone" time="1.046" /><testcase classname="tests.test_strategy_methods.TestStrategyMethods" name="test_register_cron_callback_does_nothing_in_backtesting" time="1.003" /><testcase classname="tests.test_thetadata_helper" name="test_get_price_data_with_cached_data" time="1.010" /><testcase classname="tests.test_thetadata_helper" name="test_get_price_data_without_cached_data" time="1.019" /><testcase classname="tests.test_thetadata_helper" name="test_get_price_data_partial_cache_hit" time="1.006" /><testcase classname="tests.test_thetadata_helper" name="test_get_price_data_empty_response" time="1.024" /><testcase classname="tests.test_thetadata_helper" name="test_get_trading_dates" time="1.249" /><testcase classname="tests.test_thetadata_helper" name="test_build_cache_filename[ohlc]" time="1.012" /><testcase classname="tests.test_thetadata_helper" name="test_build_cache_filename[quote]" time="1.012" /><testcase classname="tests.test_thetadata_helper" name="test_missing_dates" time="1.292" /><testcase classname="tests.test_thetadata_helper" name="test_update_cache[df_all0-df_cached0-ohlc]" time="1.009" /><testcase classname="tests.test_thetadata_helper" name="test_update_cache[df_all1-df_cached1-quote]" time="1.005" /><testcase classname="tests.test_thetadata_helper" name="test_load_data_from_cache[df_cached0-ohlc]" time="1.065" /><testcase classname="tests.test_thetadata_helper" name="test_load_data_from_cache[df_cached1-quote]" time="1.027" /><testcase classname="tests.test_thetadata_helper" name="test_update_df_with_empty_result" time="1.015" /><testcase classname="tests.test_thetadata_helper" name="test_update_df_empty_df_all_and_empty_result" time="1.013" /><testcase classname="tests.test_thetadata_helper" name="test_update_df_empty_df_all_and_result_no_datetime" time="1.015" /><testcase classname="tests.test_thetadata_helper" name="test_update_df_empty_df_all_with_new_data" time="1.010"><failure message="AssertionError: assert Timestamp('2023-07-01 13:30:00+0000', tz='UTC') == Timestamp('2023-07-01 13:29:00+0000', tz='UTC')">def test_update_df_empty_df_all_with_new_data():
        result = pd.DataFrame(
                {
                    "close": [2, 3, 4, 5, 6],
                    "open": [1, 2, 3, 4, 5],
                    "datetime": [
                        "2023-07-01 09:30:00",
                        "2023-07-01 09:31:00",
                        "2023-07-01 09:32:00",
                        "2023-07-01 09:33:00",
                        "2023-07-01 09:34:00",
                    ],
                }
            )
    
        result["datetime"] = pd.to_datetime(result["datetime"])
        df_all = None
        df_new = thetadata_helper.update_df(df_all, result)
    
        assert len(df_new) == 5
        assert df_new["close"].iloc[0] == 2
    
        # updated_df will update NewYork time to UTC time, and minus 1 min to match with polygon data
&gt;       assert df_new.index[0] == pd.DatetimeIndex(["2023-07-01 13:29:00-00:00"])[0]
E       AssertionError: assert Timestamp('2023-07-01 13:30:00+0000', tz='UTC') == Timestamp('2023-07-01 13:29:00+0000', tz='UTC')

tests/test_thetadata_helper.py:484: AssertionError</failure></testcase><testcase classname="tests.test_thetadata_helper" name="test_update_df_existing_df_all_with_new_data" time="1.001"><failure message="AssertionError: assert Timestamp('2023-08-01 13:30:00+0000', tz='UTC') == Timestamp('2023-08-01 13:29:00+0000', tz='UTC')">def test_update_df_existing_df_all_with_new_data():
        # Test with existing dataframe and new data
        initial_data = [
            {"o": 1, "h": 4, "l": 1, "c": 2, "v": 100, "t": 1690896600000},
            {"o": 5, "h": 8, "l": 3, "c": 7, "v": 100, "t": 1690896660000},
        ]
        for r in initial_data:
            r["datetime"] = pd.to_datetime(r.pop("t"), unit='ms', utc=True)
    
        df_all = pd.DataFrame(initial_data).set_index("datetime")
    
        new_data = [
            {"o": 9, "h": 12, "l": 7, "c": 10, "v": 100, "t": 1690896720000},
            {"o": 13, "h": 16, "l": 11, "c": 14, "v": 100, "t": 1690896780000},
        ]
        for r in new_data:
            r["datetime"] = pd.to_datetime(r.pop("t"), unit='ms', utc=True)
    
        new_data = pd.DataFrame(new_data)
        df_new = thetadata_helper.update_df(df_all, new_data)
    
        assert len(df_new) == 4
        assert df_new["c"].iloc[0] == 2
        assert df_new["c"].iloc[2] == 10
&gt;       assert df_new.index[0] == pd.DatetimeIndex(["2023-08-01 13:29:00+00:00"])[0]
E       AssertionError: assert Timestamp('2023-08-01 13:30:00+0000', tz='UTC') == Timestamp('2023-08-01 13:29:00+0000', tz='UTC')

tests/test_thetadata_helper.py:511: AssertionError</failure></testcase><testcase classname="tests.test_thetadata_helper" name="test_update_df_with_overlapping_data" time="1.003"><failure message="AssertionError: assert Timestamp('2023-08-01 13:30:00+0000', tz='UTC') == Timestamp('2023-08-01 13:29:00+0000', tz='UTC')">def test_update_df_with_overlapping_data():
        # Test with some overlapping rows
        initial_data = [
            {"o": 1, "h": 4, "l": 1, "c": 2, "v": 100, "t": 1690896600000},
            {"o": 5, "h": 8, "l": 3, "c": 7, "v": 100, "t": 1690896660000},
            {"o": 9, "h": 12, "l": 7, "c": 10, "v": 100, "t": 1690896720000},
            {"o": 13, "h": 16, "l": 11, "c": 14, "v": 100, "t": 1690896780000},
        ]
        for r in initial_data:
            r["datetime"] = pd.to_datetime(r.pop("t"), unit='ms', utc=True)
    
        df_all = pd.DataFrame(initial_data).set_index("datetime")
    
        overlapping_data = [
            {"o": 17, "h": 20, "l": 15, "c": 18, "v": 100, "t": 1690896780000},
            {"o": 21, "h": 24, "l": 19, "c": 22, "v": 100, "t": 1690896840000},
        ]
        for r in overlapping_data:
            r["datetime"] = pd.to_datetime(r.pop("t"), unit='ms', utc=True)
        overlapping_data = pd.DataFrame(overlapping_data).set_index("datetime")
        df_new = thetadata_helper.update_df(df_all, overlapping_data)
    
        assert len(df_new) == 5
        assert df_new["c"].iloc[0] == 2
        assert df_new["c"].iloc[2] == 10
        assert df_new["c"].iloc[3] == 14 # This is the overlapping row, should keep the first value from df_all
        assert df_new["c"].iloc[4] == 22
&gt;       assert df_new.index[0] == pd.DatetimeIndex(["2023-08-01 13:29:00+00:00"])[0]
E       AssertionError: assert Timestamp('2023-08-01 13:30:00+0000', tz='UTC') == Timestamp('2023-08-01 13:29:00+0000', tz='UTC')

tests/test_thetadata_helper.py:541: AssertionError</failure></testcase><testcase classname="tests.test_thetadata_helper" name="test_update_df_with_timezone_awareness" time="1.005" /><testcase classname="tests.test_thetadata_helper" name="test_start_theta_data_client" time="3.179"><failure message="AssertionError: Expected 'ThetaClient' to be called once. Called 0 times.">self = &lt;MagicMock name='ThetaClient' id='21547205648'&gt;, args = ()
kwargs = {'passwd': 'test_password', 'username': 'test_user'}
msg = "Expected 'ThetaClient' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
&gt;           raise AssertionError(msg)
E           AssertionError: Expected 'ThetaClient' to be called once. Called 0 times.

/opt/homebrew/Cellar/python@3.12/3.12.10/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:960: AssertionError

During handling of the above exception, another exception occurred:

mock_ThetaClient = &lt;MagicMock name='ThetaClient' id='21547205648'&gt;
mock_get = &lt;MagicMock name='get' id='21733980640'&gt;

    @patch('lumibot.tools.thetadata_helper.requests.get')  # Mock the requests.get call
    @patch('lumibot.tools.thetadata_helper.ThetaClient')  # Mock the ThetaClient class
    def test_start_theta_data_client(mock_ThetaClient,mock_get):
        # Arrange
        mock_get.return_value = MagicMock(status_code=200)
        mock_client_instance = MagicMock()
        mock_ThetaClient.return_value = mock_client_instance
        BASE_URL = "http://127.0.0.1:25510"
        # Act
        client = thetadata_helper.start_theta_data_client("test_user", "test_password")
    
        # Assert
        mock_get.assert_called_once_with(f"{BASE_URL}/v2/system/terminal/shutdown")
&gt;       mock_ThetaClient.assert_called_once_with(username="test_user", passwd="test_password")
E       AssertionError: Expected 'ThetaClient' to be called once. Called 0 times.

tests/test_thetadata_helper.py:574: AssertionError</failure></testcase><testcase classname="tests.test_thetadata_helper" name="test_check_connection" time="1.026" /><testcase classname="tests.test_thetadata_helper" name="test_check_connection_with_exception" time="1.028" /><testcase classname="tests.test_thetadata_helper" name="test_get_request_successful" time="1.009"><failure message="KeyError: 'response'">mock_get = &lt;MagicMock name='get' id='21736379680'&gt;
mock_check_connection = &lt;MagicMock name='check_connection' id='21733987088'&gt;

    @patch('lumibot.tools.thetadata_helper.check_connection')
    @patch('lumibot.tools.thetadata_helper.requests.get')
    def test_get_request_successful(mock_get, mock_check_connection):
        # Arrange
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "header": {
                "error_type": "null"
            },
            "data": "some_data"
        }
        mock_get.return_value = mock_response
    
        url = "http://test.com"
        headers = {"Authorization": "Bearer test_token"}
        querystring = {"param1": "value1"}
    
        # Act
&gt;       response = thetadata_helper.get_request(url, headers, querystring, "test_user", "test_password")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_thetadata_helper.py:639: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://test.com', headers = {'Authorization': 'Bearer test_token'}
querystring = {'param1': 'value1'}, username = 'test_user'
password = 'test_password'

                con_text = res.text
    
                if con_text == "CONNECTED":
                    logger.debug("Connected to Theta Data!")
                    connected = True
                    break
                elif con_text == "DISCONNECTED":
                    logger.debug("Disconnected from Theta Data!")
                    counter += 1
                else:
                    logger.info(f"Unknown connection status: {con_text}, starting theta data client")
                    client = start_theta_data_client(username=username, password=password)
                    counter += 1
            except Exception as e:
                # Process might have died or network issue
                if not is_process_alive():
                    logger.warning(f"ThetaTerminal process died during connection check: {e}")
                client = start_theta_data_client(username=username, password=password)
                counter += 1
    
            if counter &gt; MAX_RETRIES:
                logger.error("Cannot connect to Theta Data!")
                break
    
        return client, connected
    
    
    def get_request(url: str, headers: dict, querystring: dict, username: str, password: str):
        all_responses = []
        next_page_url = None
        page_count = 0
    
        while True:
            counter = 0
            # Use next_page URL if available, otherwise use original URL with querystring
            request_url = next_page_url if next_page_url else url
            request_params = None if next_page_url else querystring
    
            while True:
                try:
                    response = requests.get(request_url, headers=headers, params=request_params)
                    # If status code is not 200, then we are not connected
                    if response.status_code != 200:
&gt;                       check_connection(username=username, password=password)
                                 ^^^^^^^^^^^^^^^^^^^^^
E                       KeyError: 'response'

lumibot/tools/thetadata_helper.py:495: KeyError</failure></testcase><testcase classname="tests.test_thetadata_helper" name="test_get_request_non_200_status_code" time="1.025" /><testcase classname="tests.test_thetadata_helper" name="test_get_request_error_in_json" time="1.014" /><testcase classname="tests.test_thetadata_helper" name="test_get_request_exception_handling" time="1.010" /><testcase classname="tests.test_thetadata_helper" name="test_get_historical_data_stock" time="1.008"><failure message="AssertionError: assert ['open', 'hig...ume', 'count'] == ['open', 'hig... 'count', ...]&#10;  &#10;  Right contains one more item: 'datetime'&#10;  &#10;  Full diff:&#10;    [&#10;        'open',&#10;        'high',...&#10;  &#10;  ...Full output truncated (6 lines hidden), use '-vv' to show">mock_get_request = &lt;MagicMock name='get_request' id='21734682320'&gt;

    @patch('lumibot.tools.thetadata_helper.get_request')
    def test_get_historical_data_stock(mock_get_request):
        # Arrange
        mock_json_response = {
            "header": {"format": ["date", "ms_of_day", "open", "high", "low", "close", "volume", "count"]},
            "response": [
                {"date": 20230701, "ms_of_day": 3600000, "open": 100, "high": 110, "low": 95, "close": 105, "volume": 1000, "count": 10},
                {"date": 20230702, "ms_of_day": 7200000, "open": 110, "high": 120, "low": 105, "close": 115, "volume": 2000, "count": 20}
            ]
        }
        mock_get_request.return_value = mock_json_response
    
        #asset = MockAsset(asset_type="stock", symbol="AAPL")
        asset = Asset("AAPL")
        start_dt = datetime.datetime(2023, 7, 1)
        end_dt = datetime.datetime(2023, 7, 2)
        ivl = 60000
    
        # Act
        df = thetadata_helper.get_historical_data(asset, start_dt, end_dt, ivl, "test_user", "test_password")
    
        # Assert
        assert isinstance(df, pd.DataFrame)
        assert not df.empty
&gt;       assert list(df.columns) == ["open", "high", "low", "close", "volume", "count", "datetime"]
E       AssertionError: assert ['open', 'hig...ume', 'count'] == ['open', 'hig... 'count', ...]
E         
E         Right contains one more item: 'datetime'
E         
E         Full diff:
E           [
E               'open',
E               'high',...
E         
E         ...Full output truncated (6 lines hidden), use '-vv' to show

tests/test_thetadata_helper.py:749: AssertionError</failure></testcase><testcase classname="tests.test_thetadata_helper" name="test_get_historical_data_option" time="1.017"><failure message="AssertionError: assert ['open', 'hig...ume', 'count'] == ['open', 'hig... 'count', ...]&#10;  &#10;  Right contains one more item: 'datetime'&#10;  &#10;  Full diff:&#10;    [&#10;        'open',&#10;        'high',...&#10;  &#10;  ...Full output truncated (6 lines hidden), use '-vv' to show">mock_get_request = &lt;MagicMock name='get_request' id='21734677712'&gt;

    @patch('lumibot.tools.thetadata_helper.get_request')
    def test_get_historical_data_option(mock_get_request):
        # Arrange
        mock_json_response = {
            "header": {"format": ["date", "ms_of_day", "open", "high", "low", "close", "volume", "count"]},
            "response": [
                {"date": 20230701, "ms_of_day": 3600000, "open": 1, "high": 1.1, "low": 0.95, "close": 1.05, "volume": 100, "count": 10},
                {"date": 20230702, "ms_of_day": 7200000, "open": 1.1, "high": 1.2, "low": 1.05, "close": 1.15, "volume": 200, "count": 20}
            ]
        }
        mock_get_request.return_value = mock_json_response
    
        asset = Asset(
            asset_type="option", symbol="AAPL", expiration=datetime.datetime(2023, 9, 30), strike=140, right="CALL"
        )
        start_dt = datetime.datetime(2023, 7, 1)
        end_dt = datetime.datetime(2023, 7, 2)
        ivl = 60000
    
        # Act
        df = thetadata_helper.get_historical_data(asset, start_dt, end_dt, ivl, "test_user", "test_password")
    
        # Assert
        assert isinstance(df, pd.DataFrame)
        assert not df.empty
&gt;       assert list(df.columns) == ["open", "high", "low", "close", "volume", "count", "datetime"]
E       AssertionError: assert ['open', 'hig...ume', 'count'] == ['open', 'hig... 'count', ...]
E         
E         Right contains one more item: 'datetime'
E         
E         Full diff:
E           [
E               'open',
E               'high',...
E         
E         ...Full output truncated (6 lines hidden), use '-vv' to show

tests/test_thetadata_helper.py:781: AssertionError</failure></testcase><testcase classname="tests.test_thetadata_helper" name="test_get_historical_data_empty_response" time="1.020" /><testcase classname="tests.test_thetadata_helper" name="test_get_historical_data_quote_style" time="1.009" /><testcase classname="tests.test_thetadata_helper" name="test_get_historical_data_ohlc_style_with_zero_in_response" time="1.008" /><testcase classname="tests.test_thetadata_helper" name="test_get_expirations_normal_operation" time="1.016" /><testcase classname="tests.test_thetadata_helper" name="test_get_expirations_empty_response" time="1.021" /><testcase classname="tests.test_thetadata_helper" name="test_get_expirations_dates_before_after_date" time="1.015" /><testcase classname="tests.test_thetadata_helper" name="test_get_strikes_normal_operation" time="0.992" /><testcase classname="tests.test_thetadata_helper" name="test_get_strikes_empty_response" time="0.997" /><testcase classname="tests.test_tradier.TestTradierBrokerAPI" name="test_get_last_price" time="0.994"><skipped type="pytest.skip" message="These tests require a Tradier API key">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_tradier.py:40: These tests require a Tradier API key</skipped></testcase><testcase classname="tests.test_tradier.TestTradierBrokerAPI" name="test_submit_order" time="1.008"><skipped type="pytest.skip" message="These tests require a Tradier API key">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_tradier.py:46: These tests require a Tradier API key</skipped></testcase><testcase classname="tests.test_tradier.TestTradierBroker" name="test_basics" time="1.004" /><testcase classname="tests.test_tradier.TestTradierBroker" name="test_modify_order" time="0.991" /><testcase classname="tests.test_tradier.TestTradierBroker" name="test_tradier_side2lumi" time="0.985" /><testcase classname="tests.test_tradier.TestTradierBroker" name="test_lumi_side2tradier" time="0.989" /><testcase classname="tests.test_tradier.TestTradierBroker" name="test_pull_broker_all_orders" time="0.994" /><testcase classname="tests.test_tradier.TestTradierBroker" name="test_parse_broker_order" time="0.987" /><testcase classname="tests.test_tradier.TestTradierBroker" name="test_oco_parse_broker_order" time="0.999" /><testcase classname="tests.test_tradier.TestTradierBroker" name="test_do_polling" time="0.000"><skipped type="pytest.skip" message="Complex test that requires proper stream setup - skipping to fix CI timeout">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_tradier.py:365: Complex test that requires proper stream setup - skipping to fix CI timeout</skipped></testcase><testcase classname="tests.test_tradingfee.TestTradingFee" name="test_init" time="0.989" /><testcase classname="tests.test_tradovate.TestTradovateImports" name="test_tradovate_broker_import" time="1.000" /><testcase classname="tests.test_tradovate.TestTradovateImports" name="test_tradovate_data_source_import" time="1.003" /><testcase classname="tests.test_tradovate.TestTradovateImports" name="test_tradovate_exception_import" time="0.996" /><testcase classname="tests.test_tradovate.TestTradovateImports" name="test_old_misspelling_not_accessible" time="1.008" /><testcase classname="tests.test_tradovate.TestTradovateConfiguration" name="test_tradovate_config_structure" time="1.013" /><testcase classname="tests.test_tradovate.TestTradovateConfiguration" name="test_tradovate_config_default_values" time="1.001" /><testcase classname="tests.test_tradovate.TestTradovateConfiguration" name="test_environment_variable_names" time="0.000"><skipped type="pytest.skip" message="Test reloads credentials module which triggers actual API calls in CI">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_tradovate.py:90: Test reloads credentials module which triggers actual API calls in CI</skipped></testcase><testcase classname="tests.test_tradovate.TestTradovateConfiguration" name="test_tradovate_env_var_prefix" time="0.991" /><testcase classname="tests.test_tradovate.TestTradovateBroker" name="test_broker_class_attributes" time="0.991" /><testcase classname="tests.test_tradovate.TestTradovateBroker" name="test_broker_has_required_methods" time="1.008" /><testcase classname="tests.test_tradovate.TestTradovateBroker" name="test_broker_config_validation" time="0.996" /><testcase classname="tests.test_tradovate.TestTradovateBroker" name="test_broker_handles_missing_credentials" time="1.013" /><testcase classname="tests.test_tradovate.TestTradovateDataSource" name="test_data_source_attributes" time="1.000" /><testcase classname="tests.test_tradovate.TestTradovateDataSource" name="test_data_source_initialization" time="0.993" /><testcase classname="tests.test_tradovate.TestTradovateSymbolConversion" name="test_continuous_futures_symbol_resolution" time="1.022" /><testcase classname="tests.test_tradovate.TestTradovateSymbolConversion" name="test_order_symbol_extraction" time="1.006" /><testcase classname="tests.test_tradovate.TestTradovateIntegration" name="test_end_to_end_order_flow" time="0.982" /><testcase classname="tests.test_tradovate.TestTradovateSymbolResolution" name="test_tradovate_symbol_format" time="0.993" /><testcase classname="tests.test_tradovate.TestTradovateSymbolResolution" name="test_tradovate_converts_specific_contract_to_single_digit" time="1.010" /><testcase classname="tests.test_tradovate.TestTradovateSymbolResolution" name="test_tradovate_vs_standard_symbol_difference" time="1.005" /><testcase classname="tests.test_tradovate.TestTradovateAPIPayload" name="test_limit_order_payload_format" time="1.000" /><testcase classname="tests.test_tradovate.TestTradovateAPIPayload" name="test_stop_order_payload_format" time="0.984" /><testcase classname="tests.test_tradovate.TestTradovateTokenRenewal" name="test_token_renewal_on_expiry" time="0.979" /><testcase classname="tests.test_tradovate.TestTradovateTokenRenewal" name="test_automatic_retry_on_401" time="0.983" /><testcase classname="tests.test_tradovate.TestTradovateTokenRenewal" name="test_get_balances_with_token_renewal" time="0.000"><skipped type="pytest.skip" message="This test requires Tradovate credentials">/Users/robertgrzesik/Documents/Development/lumivest_bot_server/strategies/lumibot/tests/test_tradovate.py:715: This test requires Tradovate credentials</skipped></testcase><testcase classname="tests.test_tradovate.TestTradovateTokenRenewal" name="test_proactive_token_check" time="0.980" /><testcase classname="tests.test_tradovate.TestTradovateTokenRenewal" name="test_token_not_renewed_when_fresh" time="1.021" /><testcase classname="tests.test_unified_logger.TestBasicLogging" name="test_logger_hierarchy" time="0.981" /><testcase classname="tests.test_unified_logger.TestBasicLogging" name="test_logger_already_starts_with_lumibot" time="0.992" /><testcase classname="tests.test_unified_logger.TestBasicLogging" name="test_strategy_logger_prefix" time="0.980" /><testcase classname="tests.test_unified_logger.TestBasicLogging" name="test_strategy_logger_update_name" time="1.011" /><testcase classname="tests.test_unified_logger.TestCSVErrorHandler" name="test_csv_handler_initialization" time="0.975" /><testcase classname="tests.test_unified_logger.TestCSVErrorHandler" name="test_csv_file_creation" time="0.979" /><testcase classname="tests.test_unified_logger.TestCSVErrorHandler" name="test_error_deduplication" time="0.981" /><testcase classname="tests.test_unified_logger.TestCSVErrorHandler" name="test_error_details_normalization" time="0.985" /><testcase classname="tests.test_unified_logger.TestLoggerConfiguration" name="test_set_log_level" time="0.987" /><testcase classname="tests.test_unified_logger.TestLoggerConfiguration" name="test_invalid_log_level" time="0.988" /><testcase classname="tests.test_unified_logger.TestLoggerFormatter" name="test_formatter_creates_different_formats" time="0.989" /><testcase classname="tests.test_unified_logger.TestLoggerFormatter" name="test_message_cleaning" time="1.006" /><testcase classname="tests.test_unified_logger.TestThreadSafety" name="test_concurrent_csv_logging" time="1.127" /><testcase classname="tests.test_unified_logger.TestEnvironmentVariables" name="test_backtesting_quiet_logs" time="0.990" /><testcase classname="tests.test_vix_helper.TestVixHelperImport" name="test_numpy_nan_compatibility" time="1.090" /><testcase classname="tests.test_vix_helper.TestVixHelperImport" name="test_pandas_ta_import_with_numpy_2" time="0.988" /><testcase classname="tests.test_vix_helper.TestVixHelper" name="test_check_max_vix_1d" time="0.990" /><testcase classname="tests.test_vix_helper.TestVixHelper" name="test_get_vix_rsi_value" time="0.987" /><testcase classname="tests.test_vix_helper.TestVixHelper" name="test_get_vix_value" time="0.995" /><testcase classname="tests.test_vix_helper.TestVixHelper" name="test_vix_helper_initialization" time="0.979" /><testcase classname="tests.test_vix_helper.TestVixHelper" name="test_vix_percentile_calculation" time="0.982" /><testcase classname="tests.test_vix_helper.TestNumPyCompatibility" name="test_module_import_order_independence" time="1.000" /><testcase classname="tests.test_vix_helper.TestNumPyCompatibility" name="test_numpy_nan_alias_creation" time="0.999" /><testcase classname="tests.test_vix_helper.TestNumPyCompatibility" name="test_pandas_operations_with_nan" time="6.179" /></testsuite></testsuites>